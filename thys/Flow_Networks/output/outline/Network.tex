%
\begin{isabellebody}%
\setisabellecontext{Network}%
%
\isamarkupsection{Flows, Cuts, and Networks%
}
\isamarkuptrue%
%
\isadelimtheory
%
\endisadelimtheory
%
\isatagtheory
\isacommand{theory}\isamarkupfalse%
\ Network\isanewline
\isakeyword{imports}\ Graph\isanewline
\isakeyword{begin}%
\endisatagtheory
{\isafoldtheory}%
%
\isadelimtheory
%
\endisadelimtheory
%
\begin{isamarkuptext}%
In this theory, we define the basic concepts of flows, cuts, 
  and (flow) networks.%
\end{isamarkuptext}\isamarkuptrue%
%
\isamarkupsubsection{Definitions%
}
\isamarkuptrue%
%
\isamarkupsubsubsection{Flows%
}
\isamarkuptrue%
%
\begin{isamarkuptext}%
An \isa{s}-\isa{t} preflow on a graph is a labeling of the edges with 
  values from a linearly ordered integral domain, such that: 
  \begin{description}
    \item[capacity constraint] the flow on each edge is non-negative and 
      does not exceed the edge's capacity;
    \item[non-deficiency constraint] for all nodes except \isa{s} and \isa{t}, 
      the incoming flow greater or equal to the outgoing flow.
  \end{description}%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{type{\isacharunderscore}synonym}\isamarkupfalse%
\ {\isacharprime}capacity\ flow\ {\isacharequal}\ {\isachardoublequoteopen}edge\ {\isasymRightarrow}\ {\isacharprime}capacity{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{locale}\isamarkupfalse%
\ Preflow\ {\isacharequal}\ Graph\ c\ \isakeyword{for}\ c\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}capacity{\isacharcolon}{\isacharcolon}linordered{\isacharunderscore}idom\ graph{\isachardoublequoteclose}\ {\isacharplus}\isanewline
\ \ \isakeyword{fixes}\ s\ t\ {\isacharcolon}{\isacharcolon}\ node\isanewline
\ \ \isakeyword{fixes}\ f\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}capacity\ flow{\isachardoublequoteclose}\ \ \isanewline
\ \ \isanewline
\ \ \isakeyword{assumes}\ capacity{\isacharunderscore}const{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}e{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ f\ e\ {\isasymand}\ f\ e\ {\isasymle}\ c\ e{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ no{\isacharunderscore}deficient{\isacharunderscore}nodes{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}v\ {\isasymin}\ V{\isacharminus}{\isacharbraceleft}s{\isacharcomma}t{\isacharbraceright}{\isachardot}\isanewline
\ \ \ \ {\isacharparenleft}{\isasymSum}e{\isasymin}outgoing\ v{\isachardot}\ f\ e{\isacharparenright}\ {\isasymle}\ {\isacharparenleft}{\isasymSum}e{\isasymin}incoming\ v{\isachardot}\ f\ e{\isacharparenright}{\isachardoublequoteclose}\ \isanewline
\isakeyword{begin}\isanewline
\isacommand{end}\isamarkupfalse%
%
\begin{isamarkuptext}%
An \isa{s}-\isa{t} \emph{flow} on a graph is a preflow that has no active nodes except 
  source and sink, where a node is \emph{active} iff it has more incoming flow 
  than outgoing flow.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{locale}\isamarkupfalse%
\ Flow\ {\isacharequal}\ Preflow\ c\ s\ t\ f\isanewline
\ \ \isakeyword{for}\ c\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}capacity{\isacharcolon}{\isacharcolon}linordered{\isacharunderscore}idom\ graph{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{and}\ s\ t\ {\isacharcolon}{\isacharcolon}\ node\isanewline
\ \ \isakeyword{and}\ f\ {\isacharplus}\isanewline
\ \ \isakeyword{assumes}\ no{\isacharunderscore}active{\isacharunderscore}nodes{\isacharcolon}\ \isanewline
\ \ \ \ {\isachardoublequoteopen}{\isasymforall}v\ {\isasymin}\ V\ {\isacharminus}\ {\isacharbraceleft}s{\isacharcomma}t{\isacharbraceright}{\isachardot}\ {\isacharparenleft}{\isasymSum}e{\isasymin}outgoing\ v{\isachardot}\ f\ e{\isacharparenright}\ {\isasymge}\ {\isacharparenleft}{\isasymSum}e{\isasymin}incoming\ v{\isachardot}\ f\ e{\isacharparenright}{\isachardoublequoteclose}\isanewline
\isakeyword{begin}%
\begin{isamarkuptext}%
For a flow, inflow equals outflow for all nodes except sink and source.
    This is called \emph{conservation}.%
\end{isamarkuptext}\isamarkuptrue%
\ \ \isacommand{lemma}\isamarkupfalse%
\ conservation{\isacharunderscore}const{\isacharcolon}\ \isanewline
\ \ \ \ {\isachardoublequoteopen}{\isasymforall}v\ {\isasymin}\ V\ {\isacharminus}\ {\isacharbraceleft}s{\isacharcomma}\ t{\isacharbraceright}{\isachardot}\ {\isacharparenleft}{\isasymSum}e\ {\isasymin}\ incoming\ v{\isachardot}\ f\ e{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}{\isasymSum}e\ {\isasymin}\ outgoing\ v{\isachardot}\ f\ e{\isacharparenright}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ \ \ %
\endisadelimproof
%
\isatagproof
\isacommand{using}\isamarkupfalse%
\ no{\isacharunderscore}deficient{\isacharunderscore}nodes\ no{\isacharunderscore}active{\isacharunderscore}nodes\ \isanewline
\ \ \ \ \isacommand{by}\isamarkupfalse%
\ force%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
The value of a flow is the flow that leaves $s$ and does not return.%
\end{isamarkuptext}\isamarkuptrue%
\ \ \isacommand{definition}\isamarkupfalse%
\ val\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}capacity{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{where}\ {\isachardoublequoteopen}val\ {\isasymequiv}\ {\isacharparenleft}{\isasymSum}e\ {\isasymin}\ outgoing\ s{\isachardot}\ f\ e{\isacharparenright}\ {\isacharminus}\ {\isacharparenleft}{\isasymSum}e\ {\isasymin}\ incoming\ s{\isachardot}\ f\ e{\isacharparenright}{\isachardoublequoteclose}\isanewline
\isacommand{end}\isamarkupfalse%
\isanewline
\isanewline
\isacommand{locale}\isamarkupfalse%
\ Finite{\isacharunderscore}Preflow\ {\isacharequal}\ Preflow\ c\ s\ t\ f\ {\isacharplus}\ Finite{\isacharunderscore}Graph\ c\ \isanewline
\ \ \isakeyword{for}\ c\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}capacity{\isacharcolon}{\isacharcolon}linordered{\isacharunderscore}idom\ graph{\isachardoublequoteclose}\ \isakeyword{and}\ s\ t\ f\isanewline
\ \ \isanewline
\isacommand{locale}\isamarkupfalse%
\ Finite{\isacharunderscore}Flow\ {\isacharequal}\ Flow\ c\ s\ t\ f\ {\isacharplus}\ Finite{\isacharunderscore}Preflow\ c\ s\ t\ f\isanewline
\ \ \isakeyword{for}\ c\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}capacity{\isacharcolon}{\isacharcolon}linordered{\isacharunderscore}idom\ graph{\isachardoublequoteclose}\ \isakeyword{and}\ s\ t\ f%
\isamarkupsubsubsection{Cuts%
}
\isamarkuptrue%
%
\begin{isamarkuptext}%
A \emph{cut} is a partitioning of the nodes into two sets. 
  We define it by just specifying one of the partitions. 
  The other partition is implicitly given by the remaining nodes.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{type{\isacharunderscore}synonym}\isamarkupfalse%
\ cut\ {\isacharequal}\ {\isachardoublequoteopen}node\ set{\isachardoublequoteclose}\ \isanewline
\isanewline
\isacommand{locale}\isamarkupfalse%
\ Cut\ {\isacharequal}\ Graph\ {\isacharplus}\ \ \isanewline
\ \ \isakeyword{fixes}\ k\ {\isacharcolon}{\isacharcolon}\ cut\isanewline
\ \ \isakeyword{assumes}\ cut{\isacharunderscore}ss{\isacharunderscore}V{\isacharcolon}\ {\isachardoublequoteopen}k\ {\isasymsubseteq}\ V{\isachardoublequoteclose}%
\isamarkupsubsubsection{Networks%
}
\isamarkuptrue%
%
\begin{isamarkuptext}%
A \emph{network} is a finite graph with two distinct nodes, source and sink, 
such that all edges are labeled with positive capacities. 
Moreover, we assume that 

%
\begin{itemize}%
\item The source has no incoming edges, and the sink has no outgoing edges.

\item There are no parallel edges, i.e., for any edge, the reverse edge must not be in the network.

\item Every node must lay on a path from the source to the sink.

Notes on the formalization

\item We encode the graph by a mapping \isa{c}, such that \isa{c\ {\isacharparenleft}u{\isacharcomma}v{\isacharparenright}} is 
the capacity of edge \isa{{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}}, or \isa{{\isadigit{0}}}, if there is no edge from \isa{u} to \isa{v}.
Thus, in the formalization below, we only demand 
that \isa{c\ {\isacharparenleft}u{\isacharcomma}v{\isacharparenright}\ {\isasymge}\ {\isadigit{0}}} for all \isa{u} and \isa{v}.

\item We only demand the set of nodes reachable from the source to be finite.
Together with the constraint that all nodes lay on a path from the source,
this implies that the graph is finite.%
\end{itemize}%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{locale}\isamarkupfalse%
\ Network\ {\isacharequal}\ Graph\ c\ \isakeyword{for}\ c\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}capacity{\isacharcolon}{\isacharcolon}linordered{\isacharunderscore}idom\ graph{\isachardoublequoteclose}\ {\isacharplus}\isanewline
\ \ \isakeyword{fixes}\ s\ t\ {\isacharcolon}{\isacharcolon}\ node\isanewline
\ \ \isakeyword{assumes}\ s{\isacharunderscore}node{\isacharbrackleft}simp{\isacharcomma}\ intro{\isacharbang}{\isacharbrackright}{\isacharcolon}\ {\isachardoublequoteopen}s\ {\isasymin}\ V{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ t{\isacharunderscore}node{\isacharbrackleft}simp{\isacharcomma}\ intro{\isacharbang}{\isacharbrackright}{\isacharcolon}\ {\isachardoublequoteopen}t\ {\isasymin}\ V{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ s{\isacharunderscore}not{\isacharunderscore}t{\isacharbrackleft}simp{\isacharcomma}\ intro{\isacharbang}{\isacharbrackright}{\isacharcolon}\ {\isachardoublequoteopen}s\ {\isasymnoteq}\ t{\isachardoublequoteclose}\isanewline
\ \ \ \ \isanewline
\ \ \isakeyword{assumes}\ cap{\isacharunderscore}non{\isacharunderscore}negative{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}u\ v{\isachardot}\ c\ {\isacharparenleft}u{\isacharcomma}\ v{\isacharparenright}\ {\isasymge}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ no{\isacharunderscore}incoming{\isacharunderscore}s{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}u{\isachardot}\ {\isacharparenleft}u{\isacharcomma}\ s{\isacharparenright}\ {\isasymnotin}\ E{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ no{\isacharunderscore}outgoing{\isacharunderscore}t{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}u{\isachardot}\ {\isacharparenleft}t{\isacharcomma}\ u{\isacharparenright}\ {\isasymnotin}\ E{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ no{\isacharunderscore}parallel{\isacharunderscore}edge{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}u\ v{\isachardot}\ {\isacharparenleft}u{\isacharcomma}\ v{\isacharparenright}\ {\isasymin}\ E\ {\isasymlongrightarrow}\ {\isacharparenleft}v{\isacharcomma}\ u{\isacharparenright}\ {\isasymnotin}\ E{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ nodes{\isacharunderscore}on{\isacharunderscore}st{\isacharunderscore}path{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}v\ {\isasymin}\ V{\isachardot}\ connected\ s\ v\ {\isasymand}\ connected\ v\ t{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ finite{\isacharunderscore}reachable{\isacharcolon}\ {\isachardoublequoteopen}finite\ {\isacharparenleft}reachableNodes\ s{\isacharparenright}{\isachardoublequoteclose}\isanewline
\isakeyword{begin}%
\begin{isamarkuptext}%
Edges have positive capacity%
\end{isamarkuptext}\isamarkuptrue%
\ \ \isacommand{lemma}\isamarkupfalse%
\ edge{\isacharunderscore}cap{\isacharunderscore}positive{\isacharcolon}\ {\isachardoublequoteopen}{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}{\isasymin}E\ {\isasymLongrightarrow}\ c\ {\isacharparenleft}u{\isacharcomma}v{\isacharparenright}\ {\isachargreater}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ \ \ %
\endisadelimproof
%
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ E{\isacharunderscore}def\ \isacommand{using}\isamarkupfalse%
\ cap{\isacharunderscore}non{\isacharunderscore}negative{\isacharbrackleft}THEN\ spec{\isadigit{2}}{\isacharcomma}\ of\ u\ v{\isacharbrackright}\ \isacommand{by}\isamarkupfalse%
\ simp%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
The network constraints implies that all nodes are 
    reachable from the source node%
\end{isamarkuptext}\isamarkuptrue%
\ \ \isacommand{lemma}\isamarkupfalse%
\ reachable{\isacharunderscore}is{\isacharunderscore}V{\isacharbrackleft}simp{\isacharbrackright}{\isacharcolon}\ {\isachardoublequoteopen}reachableNodes\ s\ {\isacharequal}\ V{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{proof}\isamarkupfalse%
\isanewline
\ \ \ \ \isacommand{show}\isamarkupfalse%
\ {\isachardoublequoteopen}V\ {\isasymsubseteq}\ reachableNodes\ s{\isachardoublequoteclose}\isanewline
\ \ \ \ \isacommand{unfolding}\isamarkupfalse%
\ reachableNodes{\isacharunderscore}def\ \isacommand{using}\isamarkupfalse%
\ s{\isacharunderscore}node\ nodes{\isacharunderscore}on{\isacharunderscore}st{\isacharunderscore}path\isanewline
\ \ \ \ \ \ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\ \ \isacommand{qed}\isamarkupfalse%
\ {\isacharparenleft}simp\ add{\isacharcolon}\ reachable{\isacharunderscore}ss{\isacharunderscore}V{\isacharparenright}%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
Thus, the network is actually a finite graph.%
\end{isamarkuptext}\isamarkuptrue%
\ \ \isacommand{sublocale}\isamarkupfalse%
\ Finite{\isacharunderscore}Graph\ \isanewline
%
\isadelimproof
\ \ \ \ %
\endisadelimproof
%
\isatagproof
\isacommand{apply}\isamarkupfalse%
\ unfold{\isacharunderscore}locales\isanewline
\ \ \ \ \isacommand{using}\isamarkupfalse%
\ reachable{\isacharunderscore}is{\isacharunderscore}V\ finite{\isacharunderscore}reachable\ \isacommand{by}\isamarkupfalse%
\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
Our assumptions imply that there are no self loops%
\end{isamarkuptext}\isamarkuptrue%
\ \ \isacommand{lemma}\isamarkupfalse%
\ no{\isacharunderscore}self{\isacharunderscore}loop{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}u{\isachardot}\ {\isacharparenleft}u{\isacharcomma}\ u{\isacharparenright}\ {\isasymnotin}\ E{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ \ \ %
\endisadelimproof
%
\isatagproof
\isacommand{using}\isamarkupfalse%
\ no{\isacharunderscore}parallel{\isacharunderscore}edge\ \isacommand{by}\isamarkupfalse%
\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\isanewline
\ \ \isacommand{lemma}\isamarkupfalse%
\ adjacent{\isacharunderscore}not{\isacharunderscore}self{\isacharbrackleft}simp{\isacharcomma}\ intro{\isacharbang}{\isacharbrackright}{\isacharcolon}\ {\isachardoublequoteopen}v\ {\isasymnotin}\ adjacent{\isacharunderscore}nodes\ v{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ \ \ %
\endisadelimproof
%
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ adjacent{\isacharunderscore}nodes{\isacharunderscore}def\ \isacommand{using}\isamarkupfalse%
\ no{\isacharunderscore}self{\isacharunderscore}loop\ \isanewline
\ \ \ \ \isacommand{by}\isamarkupfalse%
\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
A flow is maximal, if it has a maximal value%
\end{isamarkuptext}\isamarkuptrue%
\ \ \isacommand{definition}\isamarkupfalse%
\ isMaxFlow\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharunderscore}\ flow\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isanewline
\ \ \isakeyword{where}\ {\isachardoublequoteopen}isMaxFlow\ f\ {\isasymequiv}\ Flow\ c\ s\ t\ f\ {\isasymand}\ \isanewline
\ \ \ \ {\isacharparenleft}{\isasymforall}f{\isacharprime}{\isachardot}\ Flow\ c\ s\ t\ f{\isacharprime}\ {\isasymlongrightarrow}\ Flow{\isachardot}val\ c\ s\ f{\isacharprime}\ {\isasymle}\ Flow{\isachardot}val\ c\ s\ f{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isanewline
\ \ \isacommand{definition}\isamarkupfalse%
\ {\isachardoublequoteopen}is{\isacharunderscore}max{\isacharunderscore}flow{\isacharunderscore}val\ fv\ {\isasymequiv}\ {\isasymexists}f{\isachardot}\ isMaxFlow\ f\ {\isasymand}\ fv{\isacharequal}Flow{\isachardot}val\ c\ s\ f{\isachardoublequoteclose}\isanewline
\isanewline
\ \ \isanewline
\ \ \ \ \isanewline
\ \ \isacommand{lemma}\isamarkupfalse%
\ t{\isacharunderscore}not{\isacharunderscore}s{\isacharbrackleft}simp{\isacharbrackright}{\isacharcolon}\ {\isachardoublequoteopen}t\ {\isasymnoteq}\ s{\isachardoublequoteclose}%
\isadelimproof
\ %
\endisadelimproof
%
\isatagproof
\isacommand{using}\isamarkupfalse%
\ s{\isacharunderscore}not{\isacharunderscore}t\ \isacommand{by}\isamarkupfalse%
\ blast%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
The excess of a node is the difference between incoming and 
    outgoing flow.%
\end{isamarkuptext}\isamarkuptrue%
\ \ \isacommand{definition}\isamarkupfalse%
\ excess\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}capacity\ flow\ {\isasymRightarrow}\ node\ {\isasymRightarrow}\ {\isacharprime}capacity{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ \ \ {\isachardoublequoteopen}excess\ f\ v\ {\isasymequiv}\ {\isacharparenleft}{\isasymSum}e{\isasymin}incoming\ v{\isachardot}\ f\ e{\isacharparenright}\ {\isacharminus}\ {\isacharparenleft}{\isasymSum}e{\isasymin}outgoing\ v{\isachardot}\ f\ e{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \ \isanewline
\isacommand{end}\isamarkupfalse%
%
\isamarkupsubsubsection{Networks with Flows and Cuts%
}
\isamarkuptrue%
%
\begin{isamarkuptext}%
For convenience, we define locales for a network with a fixed flow,
  and a network with a fixed cut%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{locale}\isamarkupfalse%
\ NPreflow\ {\isacharequal}\ Network\ c\ s\ t\ {\isacharplus}\ Preflow\ c\ s\ t\ f\ \isanewline
\ \ \isakeyword{for}\ c\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}capacity{\isacharcolon}{\isacharcolon}linordered{\isacharunderscore}idom\ graph{\isachardoublequoteclose}\ \isakeyword{and}\ s\ t\ f\isanewline
\isakeyword{begin}\isanewline
\ \ \isanewline
\isacommand{end}\isamarkupfalse%
\isanewline
\ \ \ \ \isanewline
\isacommand{locale}\isamarkupfalse%
\ NFlow\ {\isacharequal}\ NPreflow\ c\ s\ t\ f\ {\isacharplus}\ Flow\ c\ s\ t\ f\ \isanewline
\ \ \isakeyword{for}\ c\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}capacity{\isacharcolon}{\isacharcolon}linordered{\isacharunderscore}idom\ graph{\isachardoublequoteclose}\ \isakeyword{and}\ s\ t\ f\isanewline
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ {\isacharparenleft}\isakeyword{in}\ Network{\isacharparenright}\ isMaxFlow{\isacharunderscore}alt{\isacharcolon}\ \isanewline
\ \ {\isachardoublequoteopen}isMaxFlow\ f\ {\isasymlongleftrightarrow}\ NFlow\ c\ s\ t\ f\ {\isasymand}\ \isanewline
\ \ \ \ {\isacharparenleft}{\isasymforall}f{\isacharprime}{\isachardot}\ NFlow\ c\ s\ t\ f{\isacharprime}\ {\isasymlongrightarrow}\ Flow{\isachardot}val\ c\ s\ f{\isacharprime}\ {\isasymle}\ Flow{\isachardot}val\ c\ s\ f{\isacharparenright}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ isMaxFlow{\isacharunderscore}def\ \ \ \ \ \isanewline
\ \ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}auto\ simp{\isacharcolon}\ NFlow{\isacharunderscore}def\ Flow{\isacharunderscore}def\ NPreflow{\isacharunderscore}def{\isacharparenright}\ intro{\isacharunderscore}locales%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
A cut in a network separates the source from the sink%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{locale}\isamarkupfalse%
\ NCut\ {\isacharequal}\ Network\ c\ s\ t\ {\isacharplus}\ Cut\ c\ k\ \isanewline
\ \ \isakeyword{for}\ c\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}capacity{\isacharcolon}{\isacharcolon}linordered{\isacharunderscore}idom\ graph{\isachardoublequoteclose}\ \isakeyword{and}\ s\ t\ k\ {\isacharplus}\isanewline
\ \ \isakeyword{assumes}\ s{\isacharunderscore}in{\isacharunderscore}cut{\isacharcolon}\ {\isachardoublequoteopen}s\ {\isasymin}\ k{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ t{\isacharunderscore}ni{\isacharunderscore}cut{\isacharcolon}\ {\isachardoublequoteopen}t\ {\isasymnotin}\ k{\isachardoublequoteclose}\isanewline
\isakeyword{begin}%
\begin{isamarkuptext}%
The capacity of the cut is the capacity of all edges going from the 
    source's side to the sink's side.%
\end{isamarkuptext}\isamarkuptrue%
\ \ \isacommand{definition}\isamarkupfalse%
\ cap\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharprime}capacity{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{where}\ {\isachardoublequoteopen}cap\ {\isasymequiv}\ {\isacharparenleft}{\isasymSum}e\ {\isasymin}\ outgoing{\isacharprime}\ k{\isachardot}\ c\ e{\isacharparenright}{\isachardoublequoteclose}\isanewline
\isacommand{end}\isamarkupfalse%
%
\begin{isamarkuptext}%
A minimum cut is a cut with minimum capacity.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ isMinCut\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharunderscore}\ graph\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ cut\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isanewline
\isakeyword{where}\ {\isachardoublequoteopen}isMinCut\ c\ s\ t\ k\ {\isasymequiv}\ NCut\ c\ s\ t\ k\ {\isasymand}\isanewline
\ \ {\isacharparenleft}{\isasymforall}k{\isacharprime}{\isachardot}\ NCut\ c\ s\ t\ k{\isacharprime}\ {\isasymlongrightarrow}\ NCut{\isachardot}cap\ c\ k\ {\isasymle}\ NCut{\isachardot}cap\ c\ k{\isacharprime}{\isacharparenright}{\isachardoublequoteclose}%
\isamarkupsubsection{Properties%
}
\isamarkuptrue%
%
\isamarkupsubsubsection{Flows%
}
\isamarkuptrue%
\isacommand{context}\isamarkupfalse%
\ Preflow\ \isanewline
\isakeyword{begin}%
\begin{isamarkuptext}%
Only edges are labeled with non-zero flows%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ zero{\isacharunderscore}flow{\isacharunderscore}simp{\isacharbrackleft}simp{\isacharbrackright}{\isacharcolon}\isanewline
\ \ {\isachardoublequoteopen}{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}{\isasymnotin}E\ {\isasymLongrightarrow}\ f{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}\ {\isacharequal}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}metis\ capacity{\isacharunderscore}const\ eq{\isacharunderscore}iff\ zero{\isacharunderscore}cap{\isacharunderscore}simp{\isacharparenright}%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ f{\isacharunderscore}non{\isacharunderscore}negative{\isacharcolon}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isasymle}\ f\ e{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{using}\isamarkupfalse%
\ capacity{\isacharunderscore}const\ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}cases\ e{\isacharparenright}\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\ \ \ \ \isanewline
\isacommand{lemma}\isamarkupfalse%
\ sum{\isacharunderscore}f{\isacharunderscore}non{\isacharunderscore}negative{\isacharcolon}\ {\isachardoublequoteopen}sum\ f\ X\ {\isasymge}\ {\isadigit{0}}{\isachardoublequoteclose}%
\isadelimproof
\ %
\endisadelimproof
%
\isatagproof
\isacommand{using}\isamarkupfalse%
\ capacity{\isacharunderscore}const\isanewline
\ \ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}auto\ simp{\isacharcolon}\ sum{\isacharunderscore}nonneg\ f{\isacharunderscore}non{\isacharunderscore}negative{\isacharparenright}%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
\ \isanewline
\ \ \ \ \isanewline
\isacommand{end}\isamarkupfalse%
\ %
\isamarkupcmt{Preflow%
}
\ \ \ \isanewline
\ \ \ \ \isanewline
\isacommand{context}\isamarkupfalse%
\ Flow\isanewline
\isakeyword{begin}%
\begin{isamarkuptext}%
We provide a useful equivalent formulation of the 
  conservation constraint.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ conservation{\isacharunderscore}const{\isacharunderscore}pointwise{\isacharcolon}\ \isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}u{\isasymin}V\ {\isacharminus}\ {\isacharbraceleft}s{\isacharcomma}t{\isacharbraceright}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isacharparenleft}{\isasymSum}v{\isasymin}E{\isacharbackquote}{\isacharbackquote}{\isacharbraceleft}u{\isacharbraceright}{\isachardot}\ f\ {\isacharparenleft}u{\isacharcomma}v{\isacharparenright}{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}{\isasymSum}v{\isasymin}E{\isasyminverse}{\isacharbackquote}{\isacharbackquote}{\isacharbraceleft}u{\isacharbraceright}{\isachardot}\ f\ {\isacharparenleft}v{\isacharcomma}u{\isacharparenright}{\isacharparenright}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{using}\isamarkupfalse%
\ conservation{\isacharunderscore}const\ assms\isanewline
\ \ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}auto\ simp{\isacharcolon}\ sum{\isacharunderscore}incoming{\isacharunderscore}pointwise\ sum{\isacharunderscore}outgoing{\isacharunderscore}pointwise{\isacharparenright}%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
The value of the flow is bounded by the capacity of the 
  outgoing edges of the source node%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ val{\isacharunderscore}bounded{\isacharcolon}\ \isanewline
\ \ {\isachardoublequoteopen}{\isacharminus}{\isacharparenleft}{\isasymSum}e{\isasymin}incoming\ s{\isachardot}\ c\ e{\isacharparenright}\ {\isasymle}\ val{\isachardoublequoteclose}\isanewline
\ \ {\isachardoublequoteopen}val\ {\isasymle}\ {\isacharparenleft}{\isasymSum}e{\isasymin}outgoing\ s{\isachardot}\ c\ e{\isacharparenright}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
\isacommand{proof}\isamarkupfalse%
\ {\isacharminus}\isanewline
\ \ \isacommand{have}\isamarkupfalse%
\ \isanewline
\ \ \ \ {\isachardoublequoteopen}sum\ f\ {\isacharparenleft}outgoing\ s{\isacharparenright}\ {\isasymle}\ sum\ c\ {\isacharparenleft}outgoing\ s{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \ \ \ {\isachardoublequoteopen}sum\ f\ {\isacharparenleft}incoming\ s{\isacharparenright}\ {\isasymle}\ sum\ c\ {\isacharparenleft}incoming\ s{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isacommand{using}\isamarkupfalse%
\ capacity{\isacharunderscore}const\ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}auto\ intro{\isacharbang}{\isacharcolon}\ sum{\isacharunderscore}mono{\isacharparenright}\isanewline
\ \ \isacommand{thus}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isacharminus}{\isacharparenleft}{\isasymSum}e{\isasymin}incoming\ s{\isachardot}\ c\ e{\isacharparenright}\ {\isasymle}\ val{\isachardoublequoteclose}\ {\isachardoublequoteopen}val\ {\isasymle}\ {\isacharparenleft}{\isasymSum}e{\isasymin}outgoing\ s{\isachardot}\ c\ e{\isacharparenright}{\isachardoublequoteclose}\ \isanewline
\ \ \ \ \isacommand{using}\isamarkupfalse%
\ sum{\isacharunderscore}f{\isacharunderscore}non{\isacharunderscore}negative{\isacharbrackleft}of\ {\isachardoublequoteopen}incoming\ s{\isachardoublequoteclose}{\isacharbrackright}\ \isanewline
\ \ \ \ \isacommand{using}\isamarkupfalse%
\ sum{\isacharunderscore}f{\isacharunderscore}non{\isacharunderscore}negative{\isacharbrackleft}of\ {\isachardoublequoteopen}outgoing\ s{\isachardoublequoteclose}{\isacharbrackright}\ \ \isanewline
\ \ \ \ \isacommand{unfolding}\isamarkupfalse%
\ val{\isacharunderscore}def\ \isacommand{by}\isamarkupfalse%
\ auto\ \isanewline
\isacommand{qed}\isamarkupfalse%
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\ \ \ \ \isanewline
%
\endisadelimproof
\ \ \ \ \isanewline
\ \ \ \ \isanewline
\isacommand{end}\isamarkupfalse%
\ %
\isamarkupcmt{Flow%
}
%
\begin{isamarkuptext}%
Introduce a flow via the conservation constraint%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ {\isacharparenleft}\isakeyword{in}\ Graph{\isacharparenright}\ intro{\isacharunderscore}Flow{\isacharcolon}\isanewline
\ \ \isakeyword{assumes}\ cap{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}e{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ f\ e\ {\isasymand}\ f\ e\ {\isasymle}\ c\ e{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ cons{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}v\ {\isasymin}\ V\ {\isacharminus}\ {\isacharbraceleft}s{\isacharcomma}\ t{\isacharbraceright}{\isachardot}\ \isanewline
\ \ \ \ {\isacharparenleft}{\isasymSum}e\ {\isasymin}\ incoming\ v{\isachardot}\ f\ e{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}{\isasymSum}e\ {\isasymin}\ outgoing\ v{\isachardot}\ f\ e{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}Flow\ c\ s\ t\ f{\isachardoublequoteclose}\ \ \isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{using}\isamarkupfalse%
\ assms\ \isacommand{by}\isamarkupfalse%
\ unfold{\isacharunderscore}locales\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\ \ \isanewline
%
\endisadelimproof
\ \ \isanewline
\isacommand{context}\isamarkupfalse%
\ Finite{\isacharunderscore}Preflow\ \isanewline
\isakeyword{begin}%
\begin{isamarkuptext}%
The summation of flows over incoming/outgoing edges can be 
  extended to a summation over all possible predecessor/successor nodes,
  as the additional flows are all zero.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sum{\isacharunderscore}outgoing{\isacharunderscore}alt{\isacharunderscore}flow{\isacharcolon}\isanewline
\ \ \isakeyword{fixes}\ g\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}edge\ {\isasymRightarrow}\ {\isacharprime}capacity{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}u{\isasymin}V{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isacharparenleft}{\isasymSum}e{\isasymin}outgoing\ u{\isachardot}\ f\ e{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}{\isasymSum}v{\isasymin}V{\isachardot}\ f\ {\isacharparenleft}u{\isacharcomma}v{\isacharparenright}{\isacharparenright}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{apply}\isamarkupfalse%
\ {\isacharparenleft}subst\ sum{\isacharunderscore}outgoing{\isacharunderscore}alt{\isacharparenright}\isanewline
\ \ \isacommand{using}\isamarkupfalse%
\ assms\ capacity{\isacharunderscore}const\isanewline
\ \ \isacommand{by}\isamarkupfalse%
\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\ \ \isanewline
\isacommand{lemma}\isamarkupfalse%
\ sum{\isacharunderscore}incoming{\isacharunderscore}alt{\isacharunderscore}flow{\isacharcolon}\isanewline
\ \ \isakeyword{fixes}\ g\ {\isacharcolon}{\isacharcolon}\ {\isachardoublequoteopen}edge\ {\isasymRightarrow}\ {\isacharprime}capacity{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}u{\isasymin}V{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isacharparenleft}{\isasymSum}e{\isasymin}incoming\ u{\isachardot}\ f\ e{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}{\isasymSum}v{\isasymin}V{\isachardot}\ f\ {\isacharparenleft}v{\isacharcomma}u{\isacharparenright}{\isacharparenright}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{apply}\isamarkupfalse%
\ {\isacharparenleft}subst\ sum{\isacharunderscore}incoming{\isacharunderscore}alt{\isacharparenright}\isanewline
\ \ \isacommand{using}\isamarkupfalse%
\ assms\ capacity{\isacharunderscore}const\isanewline
\ \ \isacommand{by}\isamarkupfalse%
\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\isacommand{end}\isamarkupfalse%
\ %
\isamarkupcmt{Finite Preflow%
}
%
\isamarkupsubsubsection{Networks%
}
\isamarkuptrue%
\isacommand{context}\isamarkupfalse%
\ Network\isanewline
\isakeyword{begin}\isanewline
\ \ \isanewline
\isacommand{lemmas}\isamarkupfalse%
\ {\isacharbrackleft}simp{\isacharbrackright}\ {\isacharequal}\ no{\isacharunderscore}incoming{\isacharunderscore}s\ no{\isacharunderscore}outgoing{\isacharunderscore}t\isanewline
\ \ \isanewline
\isacommand{lemma}\isamarkupfalse%
\ incoming{\isacharunderscore}s{\isacharunderscore}empty{\isacharbrackleft}simp{\isacharbrackright}{\isacharcolon}\ {\isachardoublequoteopen}incoming\ s\ {\isacharequal}\ {\isacharbraceleft}{\isacharbraceright}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ incoming{\isacharunderscore}def\ \isacommand{using}\isamarkupfalse%
\ no{\isacharunderscore}incoming{\isacharunderscore}s\ \isacommand{by}\isamarkupfalse%
\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\ \ \isanewline
\isacommand{lemma}\isamarkupfalse%
\ outgoing{\isacharunderscore}t{\isacharunderscore}empty{\isacharbrackleft}simp{\isacharbrackright}{\isacharcolon}\ {\isachardoublequoteopen}outgoing\ t\ {\isacharequal}\ {\isacharbraceleft}{\isacharbraceright}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ outgoing{\isacharunderscore}def\ \isacommand{using}\isamarkupfalse%
\ no{\isacharunderscore}outgoing{\isacharunderscore}t\ \isacommand{by}\isamarkupfalse%
\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\ \ \isanewline
\ \ \isanewline
\isacommand{lemma}\isamarkupfalse%
\ cap{\isacharunderscore}positive{\isacharcolon}\ {\isachardoublequoteopen}e\ {\isasymin}\ E\ {\isasymLongrightarrow}\ c\ e\ {\isachargreater}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ E{\isacharunderscore}def\ \isacommand{using}\isamarkupfalse%
\ cap{\isacharunderscore}non{\isacharunderscore}negative\ le{\isacharunderscore}neq{\isacharunderscore}trans\ \isacommand{by}\isamarkupfalse%
\ fastforce%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\ \isanewline
%
\endisadelimproof
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ V{\isacharunderscore}not{\isacharunderscore}empty{\isacharcolon}\ {\isachardoublequoteopen}V{\isasymnoteq}{\isacharbraceleft}{\isacharbraceright}{\isachardoublequoteclose}%
\isadelimproof
\ %
\endisadelimproof
%
\isatagproof
\isacommand{using}\isamarkupfalse%
\ s{\isacharunderscore}node\ \isacommand{by}\isamarkupfalse%
\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ E{\isacharunderscore}not{\isacharunderscore}empty{\isacharcolon}\ {\isachardoublequoteopen}E{\isasymnoteq}{\isacharbraceleft}{\isacharbraceright}{\isachardoublequoteclose}%
\isadelimproof
\ %
\endisadelimproof
%
\isatagproof
\isacommand{using}\isamarkupfalse%
\ V{\isacharunderscore}not{\isacharunderscore}empty\ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}auto\ simp{\isacharcolon}\ V{\isacharunderscore}def{\isacharparenright}%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
\isanewline
\ \ \ \ \isanewline
\isacommand{lemma}\isamarkupfalse%
\ card{\isacharunderscore}V{\isacharunderscore}ge{\isadigit{2}}{\isacharcolon}\ {\isachardoublequoteopen}card\ V\ {\isasymge}\ {\isadigit{2}}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
\isacommand{proof}\isamarkupfalse%
\ {\isacharminus}\isanewline
\ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isadigit{2}}\ {\isacharequal}\ card\ {\isacharbraceleft}s{\isacharcomma}t{\isacharbraceright}{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\ \ \isacommand{also}\isamarkupfalse%
\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isacharbraceleft}s{\isacharcomma}t{\isacharbraceright}\ {\isasymsubseteq}\ V{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\ \ \isacommand{hence}\isamarkupfalse%
\ {\isachardoublequoteopen}card\ {\isacharbraceleft}s{\isacharcomma}t{\isacharbraceright}\ {\isasymle}\ card\ V{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}rule{\isacharunderscore}tac\ card{\isacharunderscore}mono{\isacharparenright}\ auto\isanewline
\ \ \isacommand{finally}\isamarkupfalse%
\ \isacommand{show}\isamarkupfalse%
\ {\isacharquery}thesis\ \isacommand{{\isachardot}}\isamarkupfalse%
\ \ \ \isanewline
\isacommand{qed}\isamarkupfalse%
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\ \ \isanewline
%
\endisadelimproof
\ \ \ \ \isanewline
\isacommand{lemma}\isamarkupfalse%
\ zero{\isacharunderscore}is{\isacharunderscore}flow{\isacharcolon}\ {\isachardoublequoteopen}Flow\ c\ s\ t\ {\isacharparenleft}{\isasymlambda}{\isacharunderscore}{\isachardot}\ {\isadigit{0}}{\isacharparenright}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{using}\isamarkupfalse%
\ cap{\isacharunderscore}non{\isacharunderscore}negative\ \isacommand{by}\isamarkupfalse%
\ unfold{\isacharunderscore}locales\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\ \ \isanewline
%
\endisadelimproof
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ max{\isacharunderscore}flow{\isacharunderscore}val{\isacharunderscore}unique{\isacharcolon}\ \isanewline
\ \ {\isachardoublequoteopen}{\isasymlbrakk}is{\isacharunderscore}max{\isacharunderscore}flow{\isacharunderscore}val\ fv{\isadigit{1}}{\isacharsemicolon}\ is{\isacharunderscore}max{\isacharunderscore}flow{\isacharunderscore}val\ fv{\isadigit{2}}{\isasymrbrakk}\ {\isasymLongrightarrow}\ fv{\isadigit{1}}{\isacharequal}fv{\isadigit{2}}{\isachardoublequoteclose}\ \ \ \ \isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ is{\isacharunderscore}max{\isacharunderscore}flow{\isacharunderscore}val{\isacharunderscore}def\ isMaxFlow{\isacharunderscore}def\ \isanewline
\ \ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}auto\ simp{\isacharcolon}\ antisym{\isacharparenright}%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\ \ \isanewline
\isacommand{end}\isamarkupfalse%
\ %
\isamarkupcmt{Network%
}
%
\isamarkupsubsubsection{Networks with Flow%
}
\isamarkuptrue%
\isacommand{context}\isamarkupfalse%
\ NPreflow\ \isanewline
\isakeyword{begin}\isanewline
\isanewline
\isacommand{sublocale}\isamarkupfalse%
\ Finite{\isacharunderscore}Preflow%
\isadelimproof
\ %
\endisadelimproof
%
\isatagproof
\isacommand{by}\isamarkupfalse%
\ unfold{\isacharunderscore}locales%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
As there are no edges entering the source/leaving the sink, 
  also the corresponding flow values are zero:%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ no{\isacharunderscore}inflow{\isacharunderscore}s{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}e\ {\isasymin}\ incoming\ s{\isachardot}\ f\ e\ {\isacharequal}\ {\isadigit{0}}{\isachardoublequoteclose}\ {\isacharparenleft}\isakeyword{is}\ {\isacharquery}thesis{\isacharparenright}\isanewline
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
\isacommand{proof}\isamarkupfalse%
\ {\isacharparenleft}rule\ ccontr{\isacharparenright}\isanewline
\ \ \isacommand{assume}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isasymnot}{\isacharparenleft}{\isasymforall}e\ {\isasymin}\ incoming\ s{\isachardot}\ f\ e\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \ \isacommand{then}\isamarkupfalse%
\ \isacommand{obtain}\isamarkupfalse%
\ e\ \isakeyword{where}\ obt{\isadigit{1}}{\isacharcolon}\ {\isachardoublequoteopen}e\ {\isasymin}\ incoming\ s\ {\isasymand}\ f\ e\ {\isasymnoteq}\ {\isadigit{0}}{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse%
\ blast\isanewline
\ \ \isacommand{then}\isamarkupfalse%
\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}e\ {\isasymin}\ E{\isachardoublequoteclose}\ \isacommand{using}\isamarkupfalse%
\ incoming{\isacharunderscore}def\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\ \ \isacommand{thus}\isamarkupfalse%
\ {\isachardoublequoteopen}False{\isachardoublequoteclose}\ \isacommand{using}\isamarkupfalse%
\ obt{\isadigit{1}}\ no{\isacharunderscore}incoming{\isacharunderscore}s\ incoming{\isacharunderscore}def\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\isacommand{qed}\isamarkupfalse%
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\ \ \isanewline
\isacommand{lemma}\isamarkupfalse%
\ no{\isacharunderscore}outflow{\isacharunderscore}t{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}e\ {\isasymin}\ outgoing\ t{\isachardot}\ f\ e\ {\isacharequal}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
\isacommand{proof}\isamarkupfalse%
\ {\isacharparenleft}rule\ ccontr{\isacharparenright}\isanewline
\ \ \isacommand{assume}\isamarkupfalse%
\ {\isachardoublequoteopen}{\isasymnot}{\isacharparenleft}{\isasymforall}e\ {\isasymin}\ outgoing\ t{\isachardot}\ f\ e\ {\isacharequal}\ {\isadigit{0}}{\isacharparenright}{\isachardoublequoteclose}\isanewline
\ \ \isacommand{then}\isamarkupfalse%
\ \isacommand{obtain}\isamarkupfalse%
\ e\ \isakeyword{where}\ obt{\isadigit{1}}{\isacharcolon}\ {\isachardoublequoteopen}e\ {\isasymin}\ outgoing\ t\ {\isasymand}\ f\ e\ {\isasymnoteq}\ {\isadigit{0}}{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse%
\ blast\isanewline
\ \ \isacommand{then}\isamarkupfalse%
\ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}e\ {\isasymin}\ E{\isachardoublequoteclose}\ \isacommand{using}\isamarkupfalse%
\ outgoing{\isacharunderscore}def\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\ \ \isacommand{thus}\isamarkupfalse%
\ {\isachardoublequoteopen}False{\isachardoublequoteclose}\ \isacommand{using}\isamarkupfalse%
\ obt{\isadigit{1}}\ no{\isacharunderscore}outgoing{\isacharunderscore}t\ outgoing{\isacharunderscore}def\ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\isacommand{qed}\isamarkupfalse%
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
For an edge, there is no reverse edge, and thus, 
  no flow in the reverse direction:%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ zero{\isacharunderscore}rev{\isacharunderscore}flow{\isacharunderscore}simp{\isacharbrackleft}simp{\isacharbrackright}{\isacharcolon}\ {\isachardoublequoteopen}{\isacharparenleft}u{\isacharcomma}v{\isacharparenright}{\isasymin}E\ {\isasymLongrightarrow}\ f{\isacharparenleft}v{\isacharcomma}u{\isacharparenright}\ {\isacharequal}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{using}\isamarkupfalse%
\ no{\isacharunderscore}parallel{\isacharunderscore}edge\ \isacommand{by}\isamarkupfalse%
\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\isanewline
\ \ \ \ \isanewline
\isacommand{lemma}\isamarkupfalse%
\ excess{\isacharunderscore}non{\isacharunderscore}negative{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}v{\isasymin}V{\isacharminus}{\isacharbraceleft}s{\isacharcomma}t{\isacharbraceright}{\isachardot}\ excess\ f\ v\ {\isasymge}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ excess{\isacharunderscore}def\ \isacommand{using}\isamarkupfalse%
\ no{\isacharunderscore}deficient{\isacharunderscore}nodes\ \isacommand{by}\isamarkupfalse%
\ auto%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\ \ \isanewline
\isacommand{lemma}\isamarkupfalse%
\ excess{\isacharunderscore}nodes{\isacharunderscore}only{\isacharcolon}\ {\isachardoublequoteopen}excess\ f\ v\ {\isachargreater}\ {\isadigit{0}}\ {\isasymLongrightarrow}\ v\ {\isasymin}\ V{\isachardoublequoteclose}\ \ \isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ excess{\isacharunderscore}def\ incoming{\isacharunderscore}def\ outgoing{\isacharunderscore}def\ V{\isacharunderscore}def\ \isanewline
\ \ \isacommand{using}\isamarkupfalse%
\ sum{\isachardot}not{\isacharunderscore}neutral{\isacharunderscore}contains{\isacharunderscore}not{\isacharunderscore}neutral\ \isacommand{by}\isamarkupfalse%
\ fastforce%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\ \ \isanewline
\isacommand{lemma}\isamarkupfalse%
\ excess{\isacharunderscore}non{\isacharunderscore}negative{\isacharprime}{\isacharcolon}\ {\isachardoublequoteopen}{\isasymforall}v\ {\isasymin}\ V\ {\isacharminus}\ {\isacharbraceleft}s{\isacharbraceright}{\isachardot}\ excess\ f\ v\ {\isasymge}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
\isacommand{proof}\isamarkupfalse%
\ {\isacharminus}\isanewline
\ \ \isacommand{have}\isamarkupfalse%
\ {\isachardoublequoteopen}excess\ f\ t\ {\isasymge}\ {\isadigit{0}}{\isachardoublequoteclose}\ \isacommand{unfolding}\isamarkupfalse%
\ excess{\isacharunderscore}def\ outgoing{\isacharunderscore}def\ \isanewline
\ \ \ \ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}auto\ simp{\isacharcolon}\ capacity{\isacharunderscore}const\ sum{\isacharunderscore}nonneg{\isacharparenright}\isanewline
\ \ \isacommand{thus}\isamarkupfalse%
\ {\isacharquery}thesis\ \isacommand{using}\isamarkupfalse%
\ excess{\isacharunderscore}non{\isacharunderscore}negative\ \isacommand{by}\isamarkupfalse%
\ blast\isanewline
\isacommand{qed}\isamarkupfalse%
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\ \isanewline
%
\endisadelimproof
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ excess{\isacharunderscore}s{\isacharunderscore}non{\isacharunderscore}pos{\isacharcolon}\ {\isachardoublequoteopen}excess\ f\ s\ {\isasymle}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ %
\endisadelimproof
%
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ excess{\isacharunderscore}def\isanewline
\ \ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}simp\ add{\isacharcolon}\ capacity{\isacharunderscore}const\ sum{\isacharunderscore}nonneg{\isacharparenright}%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\ \ \isanewline
%
\endisadelimproof
\ \ \ \ \isanewline
\isacommand{end}\isamarkupfalse%
\ %
\isamarkupcmt{Network with preflow%
}
\isanewline
\isanewline
\isacommand{context}\isamarkupfalse%
\ NFlow\ \isakeyword{begin}\ \ \isanewline
\ \ \isacommand{sublocale}\isamarkupfalse%
\ Finite{\isacharunderscore}Preflow%
\isadelimproof
\ %
\endisadelimproof
%
\isatagproof
\isacommand{by}\isamarkupfalse%
\ unfold{\isacharunderscore}locales%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
There is no outflow from the sink in a network. 
    Thus, we can simplify the definition of the value:%
\end{isamarkuptext}\isamarkuptrue%
\ \ \isacommand{corollary}\isamarkupfalse%
\ val{\isacharunderscore}alt{\isacharcolon}\ {\isachardoublequoteopen}val\ {\isacharequal}\ {\isacharparenleft}{\isasymSum}e\ {\isasymin}\ outgoing\ s{\isachardot}\ f\ e{\isacharparenright}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
\ \ \ \ %
\endisadelimproof
%
\isatagproof
\isacommand{unfolding}\isamarkupfalse%
\ val{\isacharunderscore}def\ \isacommand{by}\isamarkupfalse%
\ {\isacharparenleft}auto\ simp{\isacharcolon}\ no{\isacharunderscore}inflow{\isacharunderscore}s{\isacharparenright}%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\ \ \ \ \ \ \isanewline
\isacommand{end}\isamarkupfalse%
\ \ \isanewline
%
\isadelimtheory
\ \ \isanewline
%
\endisadelimtheory
%
\isatagtheory
\isacommand{end}\isamarkupfalse%
\ %
\isamarkupcmt{Theory%
}
%
\endisatagtheory
{\isafoldtheory}%
%
\isadelimtheory
%
\endisadelimtheory
%
\end{isabellebody}%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "root"
%%% End:
