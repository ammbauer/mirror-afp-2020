<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>21 Jul 2017 00:00:00 +0000</pubDate>
    <item>
       <title>Declarative Semantics for Functional Languages</title>
              <link>https://www.isa-afp.org/entries/Decl_Sem_Fun_PL.shtml</link>
       <guid>https://www.isa-afp.org/entries/Decl_Sem_Fun_PL.shtml</guid>
       <dc:creator> Jeremy Siek       </dc:creator>
       <pubDate>21 Jul 2017 00:00:00 +0000</pubDate>
       <description>
We present a semantics for an applied call-by-value lambda-calculus
that is compositional, extensional, and elementary. We present four
different views of the semantics: 1) as a relational (big-step)
semantics that is not operational but instead declarative, 2) as a
denotational semantics that does not use domain theory, 3) as a
non-deterministic interpreter, and 4) as a variant of the intersection
type systems of the Torino group.  We prove that the semantics is
correct by showing that it is sound and complete with respect to
operational semantics on programs and that is sound with respect to
contextual equivalence. We have not yet investigated whether it is
fully abstract. We demonstrate that this approach to semantics is
useful with three case studies. First, we use the semantics to prove
correctness of a compiler optimization that inlines function
application. Second, we adapt the semantics to the polymorphic
lambda-calculus extended with general recursion and prove semantic
type soundness.  Third, we adapt the semantics to the call-by-value
lambda-calculus with mutable references.
&lt;br&gt;
The paper that accompanies these Isabelle theories is &lt;a href=&#34;https://arxiv.org/abs/1707.03762&#34;&gt;available on arXiv&lt;/a&gt;.</description>
    </item>
    <item>
       <title>HOLCF-Prelude</title>
              <link>https://www.isa-afp.org/entries/HOLCF-Prelude.shtml</link>
       <guid>https://www.isa-afp.org/entries/HOLCF-Prelude.shtml</guid>
       <dc:creator> Joachim Breitner, Brian Huffman, Neil Mitchell, Christian Sternagel       </dc:creator>
       <pubDate>15 Jul 2017 00:00:00 +0000</pubDate>
       <description>
The Isabelle/HOLCF-Prelude is a formalization of a large part of
Haskell&#39;s standard prelude in Isabelle/HOLCF. We use it to prove
the correctness of the Eratosthenes&#39; Sieve, in its
self-referential implementation commonly used to showcase
Haskell&#39;s laziness; prove correctness of GHC&#39;s
&#34;fold/build&#34; rule and related rewrite rules; and certify a
number of hints suggested by HLint.</description>
    </item>
    <item>
       <title>Minkowski's Theorem</title>
              <link>https://www.isa-afp.org/entries/Minkowskis_Theorem.shtml</link>
       <guid>https://www.isa-afp.org/entries/Minkowskis_Theorem.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>13 Jul 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;Minkowski&#39;s theorem relates a subset of
&amp;#8477;&lt;sup&gt;n&lt;/sup&gt;, the Lebesgue measure, and the
integer lattice &amp;#8484;&lt;sup&gt;n&lt;/sup&gt;: It states that
any convex subset of &amp;#8477;&lt;sup&gt;n&lt;/sup&gt; with volume
greater than 2&lt;sup&gt;n&lt;/sup&gt; contains at least one lattice
point from &amp;#8484;&lt;sup&gt;n&lt;/sup&gt;\{0}, i.&amp;thinsp;e. a
non-zero point with integer coefficients.&lt;/p&gt;  &lt;p&gt;A
related theorem which directly implies this is Blichfeldt&#39;s
theorem, which states that any subset of
&amp;#8477;&lt;sup&gt;n&lt;/sup&gt; with a volume greater than 1
contains two different points whose difference vector has integer
components.&lt;/p&gt;  &lt;p&gt;The entry contains a proof of both
theorems.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Verified Metatheory and Type Inference for a Name-Carrying Simply-Typed Lambda Calculus</title>
              <link>https://www.isa-afp.org/entries/Name_Carrying_Type_Inference.shtml</link>
       <guid>https://www.isa-afp.org/entries/Name_Carrying_Type_Inference.shtml</guid>
       <dc:creator> Michael Rawson       </dc:creator>
       <pubDate>09 Jul 2017 00:00:00 +0000</pubDate>
       <description>
I formalise a Church-style simply-typed
\(\lambda\)-calculus, extended with pairs, a unit value, and
projection functions, and show some metatheory of the calculus, such
as the subject reduction property. Particular attention is paid to the
treatment of names in the calculus. A nominal style of binding is
used, but I use a manual approach over Nominal Isabelle in order to
extract an executable type inference algorithm. More information can
be found in my &lt;a
href=&#34;http://www.openthesis.org/documents/Verified-Metatheory-Type-Inference-Simply-603182.html&#34;&gt;undergraduate
dissertation&lt;/a&gt;.</description>
    </item>
    <item>
       <title>A framework for establishing Strong Eventual Consistency for Conflict-free Replicated Datatypes</title>
              <link>https://www.isa-afp.org/entries/CRDT.shtml</link>
       <guid>https://www.isa-afp.org/entries/CRDT.shtml</guid>
       <dc:creator> Victor B. F. Gomes, Martin Kleppmann, Dominic P. Mulligan, Alastair R. Beresford       </dc:creator>
       <pubDate>07 Jul 2017 00:00:00 +0000</pubDate>
       <description>
In this work, we focus on the correctness of Conflict-free Replicated
Data Types (CRDTs), a class of algorithm that provides strong eventual
consistency guarantees for replicated data. We develop a modular and
reusable framework for verifying the correctness of CRDT algorithms.
We avoid correctness issues that have dogged previous mechanised
proofs in this area by including a network model in our formalisation,
and proving that our theorems hold in all possible network behaviours.
Our axiomatic network model is a standard abstraction that accurately
reflects the behaviour of real-world computer networks. Moreover, we
identify an abstract convergence theorem, a property of order
relations, which provides a formal definition of strong eventual
consistency. We then obtain the first machine-checked correctness
theorems for three concrete CRDTs: the Replicated Growable Array, the
Observed-Remove Set, and an Increment-Decrement Counter.</description>
    </item>
    <item>
       <title>Propositional Proof Systems</title>
              <link>https://www.isa-afp.org/entries/Propositional_Proof_Systems.shtml</link>
       <guid>https://www.isa-afp.org/entries/Propositional_Proof_Systems.shtml</guid>
       <dc:creator> Julius Michaelis, Tobias Nipkow       </dc:creator>
       <pubDate>21 Jun 2017 00:00:00 +0000</pubDate>
       <description>
We formalize a range of proof systems for classical propositional
logic (sequent calculus, natural deduction, Hilbert systems,
resolution) and prove the most important meta-theoretic results about
semantics and proofs: compactness, soundness, completeness,
translations between proof systems, cut-elimination, interpolation and
model existence.</description>
    </item>
    <item>
       <title>Partial Semigroups and Convolution Algebras</title>
              <link>https://www.isa-afp.org/entries/PSemigroupsConvolution.shtml</link>
       <guid>https://www.isa-afp.org/entries/PSemigroupsConvolution.shtml</guid>
       <dc:creator> Brijesh Dongol, Victor B. F. Gomes, Ian J. Hayes, Georg Struth       </dc:creator>
       <pubDate>13 Jun 2017 00:00:00 +0000</pubDate>
       <description>
Partial Semigroups are relevant to the foundations of quantum
mechanics and combinatorics as well as to interval and separation
logics. Convolution algebras can be understood either as algebras of
generalised binary modalities over ternary Kripke frames, in
particular over partial semigroups, or as algebras of quantale-valued
functions which are equipped with a convolution-style operation of
multiplication that is parametrised by a ternary relation. Convolution
algebras provide algebraic semantics for various substructural logics,
including categorial, relevance and linear logics, for separation
logic and for interval logics; they cover quantitative and qualitative
applications. These mathematical components for partial semigroups and
convolution algebras provide uniform foundations from which models of
computation based on relations, program traces or pomsets, and
verification components for separation or interval temporal logics can
be built with little effort.</description>
    </item>
    <item>
       <title>Buffon's Needle Problem</title>
              <link>https://www.isa-afp.org/entries/Buffons_Needle.shtml</link>
       <guid>https://www.isa-afp.org/entries/Buffons_Needle.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>06 Jun 2017 00:00:00 +0000</pubDate>
       <description>
In the 18th century, Georges-Louis Leclerc, Comte de Buffon posed and
later solved the following problem, which is often called the first
problem ever solved in geometric probability: Given a floor divided
into vertical strips of the same width, what is the probability that a
needle thrown onto the floor randomly will cross two strips?  This
entry formally defines the problem in the case where the needle&#39;s
position is chosen uniformly at random in a single strip around the
origin (which is equivalent to larger arrangements due to symmetry).
It then provides proofs of the simple solution in the case where the
needle&#39;s length is no greater than the width of the strips and
the more complicated solution in the opposite case.</description>
    </item>
    <item>
       <title>Formalizing Push-Relabel Algorithms</title>
              <link>https://www.isa-afp.org/entries/Prpu_Maxflow.shtml</link>
       <guid>https://www.isa-afp.org/entries/Prpu_Maxflow.shtml</guid>
       <dc:creator> Peter Lammich, S. Reza Sefidgar       </dc:creator>
       <pubDate>01 Jun 2017 00:00:00 +0000</pubDate>
       <description>
We present a formalization of push-relabel algorithms for computing
the maximum flow in a network. We start with Goldberg&#39;s et
al.~generic push-relabel algorithm, for which we show correctness and
the time complexity bound of O(V^2E). We then derive the
relabel-to-front and FIFO implementation. Using stepwise refinement
techniques, we derive an efficient verified implementation.  Our
formal proof of the abstract algorithms closely follows a standard
textbook proof. It is accessible even without being an expert in
Isabelle/HOL, the interactive theorem prover used for the
formalization.</description>
    </item>
    <item>
       <title>Flow Networks and the Min-Cut-Max-Flow Theorem</title>
              <link>https://www.isa-afp.org/entries/Flow_Networks.shtml</link>
       <guid>https://www.isa-afp.org/entries/Flow_Networks.shtml</guid>
       <dc:creator> Peter Lammich, S. Reza Sefidgar       </dc:creator>
       <pubDate>01 Jun 2017 00:00:00 +0000</pubDate>
       <description>
We present a formalization of flow networks and the Min-Cut-Max-Flow
theorem. Our formal proof closely follows a standard textbook proof,
and is accessible even without being an expert in Isabelle/HOL, the
interactive theorem prover used for the formalization.</description>
    </item>
    <item>
       <title>Optics</title>
              <link>https://www.isa-afp.org/entries/Optics.shtml</link>
       <guid>https://www.isa-afp.org/entries/Optics.shtml</guid>
       <dc:creator> Simon Foster, Frank Zeyda       </dc:creator>
       <pubDate>25 May 2017 00:00:00 +0000</pubDate>
       <description>
Lenses provide an abstract interface for manipulating data types
through spatially-separated views. They are defined abstractly in
terms of two functions, &lt;em&gt;get&lt;/em&gt;, the return a value
from the source type, and &lt;em&gt;put&lt;/em&gt; that updates the
value. We mechanise the underlying theory of lenses, in terms of an
algebraic hierarchy of lenses, including well-behaved and very
well-behaved lenses, each lens class being characterised by a set of
lens laws. We also mechanise a lens algebra in Isabelle that enables
their composition and comparison, so as to allow construction of
complex lenses. This is accompanied by a large library of algebraic
laws. Moreover we also show how the lens classes can be applied by
instantiating them with a number of Isabelle data types.</description>
    </item>
    <item>
       <title>Developing Security Protocols by Refinement</title>
              <link>https://www.isa-afp.org/entries/Security_Protocol_Refinement.shtml</link>
       <guid>https://www.isa-afp.org/entries/Security_Protocol_Refinement.shtml</guid>
       <dc:creator> Christoph Sprenger, Ivano Somaini       </dc:creator>
       <pubDate>24 May 2017 00:00:00 +0000</pubDate>
       <description>
We propose a development method for security protocols based on
stepwise refinement. Our refinement strategy transforms abstract
security goals into protocols that are secure when operating over an
insecure channel controlled by a Dolev-Yao-style intruder. As
intermediate levels of abstraction, we employ messageless guard
protocols and channel protocols communicating over channels with
security properties. These abstractions provide insights on why
protocols are secure and foster the development of families of
protocols sharing common structure and properties. We have implemented
our method in Isabelle/HOL and used it to develop different entity
authentication and key establishment protocols, including realistic
features such as key confirmation, replay caches, and encrypted
tickets. Our development highlights that guard protocols and channel
protocols provide fundamental abstractions for bridging the gap
between security properties and standard protocol descriptions based
on cryptographic messages. It also shows that our refinement approach
scales to protocols of nontrivial size and complexity.</description>
    </item>
    <item>
       <title>The Floyd-Warshall Algorithm for Shortest Paths</title>
              <link>https://www.isa-afp.org/entries/Floyd_Warshall.shtml</link>
       <guid>https://www.isa-afp.org/entries/Floyd_Warshall.shtml</guid>
       <dc:creator> Simon Wimmer, Peter Lammich       </dc:creator>
       <pubDate>08 May 2017 00:00:00 +0000</pubDate>
       <description>
The Floyd-Warshall algorithm [Flo62, Roy59, War62] is a classic
dynamic programming algorithm to compute the length of all shortest
paths between any two vertices in a graph (i.e. to solve the all-pairs
shortest path problem, or APSP for short). Given a representation of
the graph as a matrix of weights M, it computes another matrix M&#39;
which represents a graph with the same path lengths and contains the
length of the shortest path between any two vertices i and j. This is
only possible if the graph does not contain any negative cycles.
However, in this case the Floyd-Warshall algorithm will detect the
situation by calculating a negative diagonal entry. This entry
includes a formalization of the algorithm and of these key properties.
The algorithm is refined to an efficient imperative version using the
Imperative Refinement Framework.</description>
    </item>
    <item>
       <title>Probabilistic while loop</title>
              <link>https://www.isa-afp.org/entries/Probabilistic_While.shtml</link>
       <guid>https://www.isa-afp.org/entries/Probabilistic_While.shtml</guid>
       <dc:creator> Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
This AFP entry defines a probabilistic while operator based on
sub-probability mass functions and formalises zero-one laws and variant
rules for probabilistic loop termination. As applications, we
implement probabilistic algorithms for the Bernoulli, geometric and
arbitrary uniform distributions that only use fair coin flips, and
prove them correct and terminating with probability 1.</description>
    </item>
    <item>
       <title>Effect polymorphism in higher-order logic</title>
              <link>https://www.isa-afp.org/entries/Monomorphic_Monad.shtml</link>
       <guid>https://www.isa-afp.org/entries/Monomorphic_Monad.shtml</guid>
       <dc:creator> Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
The notion of a monad cannot be expressed within higher-order logic
(HOL) due to type system restrictions. We show that if a monad is used
with values of only one type, this notion can be formalised in HOL.
Based on this idea, we develop a library of effect specifications and
implementations of monads and monad transformers. Hence, we can
abstract over the concrete monad in HOL definitions and thus use the
same definition for different (combinations of) effects. We illustrate
the usefulness of effect polymorphism with a monadic interpreter for a
simple language.</description>
    </item>
    <item>
       <title>Monad normalisation</title>
              <link>https://www.isa-afp.org/entries/Monad_Normalisation.shtml</link>
       <guid>https://www.isa-afp.org/entries/Monad_Normalisation.shtml</guid>
       <dc:creator> Joshua Schneider, Manuel Eberl, Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
The usual monad laws can directly be used as rewrite rules for Isabelle’s
simplifier to normalise monadic HOL terms and decide equivalences.
In a commutative monad, however, the commutativity law is a
higher-order permutative rewrite rule that makes the simplifier loop.
This AFP entry implements a simproc that normalises monadic
expressions in commutative monads using ordered rewriting. The
simproc can also permute computations across control operators like if
and case.</description>
    </item>
    <item>
       <title>Game-based cryptography in HOL</title>
              <link>https://www.isa-afp.org/entries/Game_Based_Crypto.shtml</link>
       <guid>https://www.isa-afp.org/entries/Game_Based_Crypto.shtml</guid>
       <dc:creator> Andreas Lochbihler, S. Reza Sefidgar, Bhargav Bhatt       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;In this AFP entry, we show how to specify game-based cryptographic
security notions and formally prove secure several cryptographic
constructions from the literature using the CryptHOL framework. Among
others, we formalise the notions of a random oracle, a pseudo-random
function, an unpredictable function, and of encryption schemes that are
indistinguishable under chosen plaintext and/or ciphertext attacks. We
prove the random-permutation/random-function switching lemma, security
of the Elgamal and hashed Elgamal public-key encryption scheme and
correctness and security of several constructions with pseudo-random
functions.
&lt;/p&gt;&lt;p&gt;Our proofs follow the game-hopping style advocated by
Shoup and Bellare and Rogaway, from which most of the examples have
been taken. We generalise some of their results such that they can be
reused in other proofs. Thanks to CryptHOL&#39;s integration with
Isabelle&#39;s parametricity infrastructure, many simple hops are easily
justified using the theory of representation independence.&lt;/p&gt;</description>
    </item>
    <item>
       <title>CryptHOL</title>
              <link>https://www.isa-afp.org/entries/CryptHOL.shtml</link>
       <guid>https://www.isa-afp.org/entries/CryptHOL.shtml</guid>
       <dc:creator> Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;CryptHOL provides a framework for formalising cryptographic arguments
in Isabelle/HOL. It shallowly embeds a probabilistic functional
programming language in higher order logic. The language features
monadic sequencing, recursion, random sampling, failures and failure
handling, and black-box access to oracles. Oracles are probabilistic
functions which maintain hidden state between different invocations.
All operators are defined in the new semantic domain of
generative probabilistic values, a codatatype. We derive proof rules for
the operators and establish a connection with the theory of relational
parametricity. Thus, the resuting proofs are trustworthy and
comprehensible, and the framework is extensible and widely applicable.
&lt;/p&gt;&lt;p&gt;
The framework is used in the accompanying AFP entry &#34;Game-based
Cryptography in HOL&#34;. There, we show-case our framework by formalizing
different game-based proofs from the literature. This formalisation
continues the work described in the author&#39;s ESOP 2016 paper.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Monoidal Categories</title>
              <link>https://www.isa-afp.org/entries/MonoidalCategory.shtml</link>
       <guid>https://www.isa-afp.org/entries/MonoidalCategory.shtml</guid>
       <dc:creator> Eugene W. Stark       </dc:creator>
       <pubDate>04 May 2017 00:00:00 +0000</pubDate>
       <description>
Building on the formalization of basic category theory set out in the
author&#39;s previous AFP article, the present article formalizes
some basic aspects of the theory of monoidal categories. Among the
notions defined here are monoidal category, monoidal functor, and
equivalence of monoidal categories. The main theorems formalized are
MacLane&#39;s coherence theorem and the constructions of the free
monoidal category and free strict monoidal category generated by a
given category.  The coherence theorem is proved syntactically, using
a structurally recursive approach to reduction of terms that might
have some novel aspects. We also give proofs of some results given by
Etingof et al, which may prove useful in a formal setting. In
particular, we show that the left and right unitors need not be taken
as given data in the definition of monoidal category, nor does the
definition of monoidal functor need to take as given a specific
isomorphism expressing the preservation of the unit object. Our
definitions of monoidal category and monoidal functor are stated so as
to take advantage of the economy afforded by these facts.</description>
    </item>
    <item>
       <title>Types, Tableaus and Gödel’s God in Isabelle/HOL</title>
              <link>https://www.isa-afp.org/entries/Types_Tableaus_and_Goedels_God.shtml</link>
       <guid>https://www.isa-afp.org/entries/Types_Tableaus_and_Goedels_God.shtml</guid>
       <dc:creator> David Fuenmayor, Christoph Benzmüller       </dc:creator>
       <pubDate>01 May 2017 00:00:00 +0000</pubDate>
       <description>
A computer-formalisation of the essential parts of Fitting&#39;s
textbook &#34;Types, Tableaus and Gödel&#39;s God&#34; in
Isabelle/HOL is presented. In particular, Fitting&#39;s (and
Anderson&#39;s) variant of the ontological argument is verified and
confirmed. This variant avoids the modal collapse, which has been
criticised as an undesirable side-effect of Kurt Gödel&#39;s (and
Dana Scott&#39;s) versions of the ontological argument.
Fitting&#39;s work is employing an intensional higher-order modal
logic, which we shallowly embed here in classical higher-order logic.
We then utilize the embedded logic for the formalisation of
Fitting&#39;s argument. (See also the earlier AFP entry ``Gödel&#39;s God in Isabelle/HOL&#39;&#39;.)</description>
    </item>
    <item>
       <title>Local Lexing</title>
              <link>https://www.isa-afp.org/entries/LocalLexing.shtml</link>
       <guid>https://www.isa-afp.org/entries/LocalLexing.shtml</guid>
       <dc:creator> Steven Obua       </dc:creator>
       <pubDate>28 Apr 2017 00:00:00 +0000</pubDate>
       <description>
This formalisation accompanies the paper &lt;a
href=&#34;https://arxiv.org/abs/1702.03277&#34;&gt;Local
Lexing&lt;/a&gt; which introduces a novel parsing concept of the same
name. The paper also gives a high-level algorithm for local lexing as
an extension of Earley&#39;s algorithm. This formalisation proves the
algorithm to be correct with respect to its local lexing semantics. As
a special case, this formalisation thus also contains a proof of the
correctness of Earley&#39;s algorithm. The paper contains a short
outline of how this formalisation is organised.</description>
    </item>
    <item>
       <title>Constructor Functions</title>
              <link>https://www.isa-afp.org/entries/Constructor_Funs.shtml</link>
       <guid>https://www.isa-afp.org/entries/Constructor_Funs.shtml</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>19 Apr 2017 00:00:00 +0000</pubDate>
       <description>
Isabelle&#39;s code generator performs various adaptations for target
languages. Among others, constructor applications have to be fully
saturated. That means that for constructor calls occuring as arguments
to higher-order functions, synthetic lambdas have to be inserted. This
entry provides tooling to avoid this construction altogether by
introducing constructor functions.</description>
    </item>
    <item>
       <title>Lazifying case constants</title>
              <link>https://www.isa-afp.org/entries/Lazy_Case.shtml</link>
       <guid>https://www.isa-afp.org/entries/Lazy_Case.shtml</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>18 Apr 2017 00:00:00 +0000</pubDate>
       <description>
Isabelle&#39;s code generator performs various adaptations for target
languages. Among others, case statements are printed as match
expressions. Internally, this is a sophisticated procedure, because in
HOL, case statements are represented as nested calls to the case
combinators as generated by the datatype package. Furthermore, the
procedure relies on laziness of match expressions in the target
language, i.e., that branches guarded by patterns that fail to match
are not evaluated. Similarly, &lt;tt&gt;if-then-else&lt;/tt&gt; is
printed to the corresponding construct in the target language. This
entry provides tooling to replace these special cases in the code
generator by ignoring these target language features, instead printing
case expressions and &lt;tt&gt;if-then-else&lt;/tt&gt; as functions.</description>
    </item>
    <item>
       <title>Subresultants</title>
              <link>https://www.isa-afp.org/entries/Subresultants.shtml</link>
       <guid>https://www.isa-afp.org/entries/Subresultants.shtml</guid>
       <dc:creator> Sebastiaan Joosten, René Thiemann, Akihisa Yamada       </dc:creator>
       <pubDate>06 Apr 2017 00:00:00 +0000</pubDate>
       <description>
We formalize the theory of subresultants and the subresultant
polynomial remainder sequence as described by Brown and Traub. As a
result, we obtain efficient certified algorithms for computing the
resultant and the greatest common divisor of polynomials.</description>
    </item>
    <item>
       <title>Expected Shape of Random Binary Search Trees</title>
              <link>https://www.isa-afp.org/entries/Random_BSTs.shtml</link>
       <guid>https://www.isa-afp.org/entries/Random_BSTs.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>04 Apr 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry contains proofs for the textbook results about the
distributions of the height and internal path length of random binary
search trees (BSTs), i.&amp;thinsp;e. BSTs that are formed by taking
an empty BST and inserting elements from a fixed set in random
order.&lt;/p&gt;  &lt;p&gt;In particular, we prove a logarithmic upper
bound on the expected height and the &lt;em&gt;Θ(n log n)&lt;/em&gt;
closed-form solution for the expected internal path length in terms of
the harmonic numbers. We also show how the internal path length
relates to the average-case cost of a lookup in a BST.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The number of comparisons in QuickSort</title>
              <link>https://www.isa-afp.org/entries/Quick_Sort_Cost.shtml</link>
       <guid>https://www.isa-afp.org/entries/Quick_Sort_Cost.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>15 Mar 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;We give a formal proof of the well-known results about the
number of comparisons performed by two variants of QuickSort: first,
the expected number of comparisons of randomised QuickSort
(i.&amp;thinsp;e.&amp;nbsp;QuickSort with random pivot choice) is
&lt;em&gt;2&amp;thinsp;(n+1)&amp;thinsp;H&lt;sub&gt;n&lt;/sub&gt; -
4&amp;thinsp;n&lt;/em&gt;, which is asymptotically equivalent to
&lt;em&gt;2&amp;thinsp;n ln n&lt;/em&gt;; second, the number of
comparisons performed by the classic non-randomised QuickSort has the
same distribution in the average case as the randomised one.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Lower bound on comparison-based sorting algorithms</title>
              <link>https://www.isa-afp.org/entries/Comparison_Sort_Lower_Bound.shtml</link>
       <guid>https://www.isa-afp.org/entries/Comparison_Sort_Lower_Bound.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>15 Mar 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article contains a formal proof of the well-known fact
that number of comparisons that a comparison-based sorting algorithm
needs to perform to sort a list of length &lt;em&gt;n&lt;/em&gt; is at
least &lt;em&gt;log&lt;sub&gt;2&lt;/sub&gt;&amp;nbsp;(n!)&lt;/em&gt;
in the worst case, i.&amp;thinsp;e.&amp;nbsp;&lt;em&gt;Ω(n log
n)&lt;/em&gt;.&lt;/p&gt;  &lt;p&gt;For this purpose, a shallow
embedding for comparison-based sorting algorithms is defined: a
sorting algorithm is a recursive datatype containing either a HOL
function or a query of a comparison oracle with a continuation
containing the remaining computation. This makes it possible to force
the algorithm to use only comparisons and to track the number of
comparisons made.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The Euler–MacLaurin Formula</title>
              <link>https://www.isa-afp.org/entries/Euler_MacLaurin.shtml</link>
       <guid>https://www.isa-afp.org/entries/Euler_MacLaurin.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>10 Mar 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The Euler-MacLaurin formula relates the value of a
discrete sum to that of the corresponding integral in terms of the
derivatives at the borders of the summation and a remainder term.
Since the remainder term is often very small as the summation bounds
grow, this can be used to compute asymptotic expansions for
sums.&lt;/p&gt;  &lt;p&gt;This entry contains a proof of this formula
for functions from the reals to an arbitrary Banach space. Two
variants of the formula are given: the standard textbook version and a
variant outlined in &lt;em&gt;Concrete Mathematics&lt;/em&gt; that is
more useful for deriving asymptotic estimates.&lt;/p&gt;  &lt;p&gt;As
example applications, we use that formula to derive the full
asymptotic expansion of the harmonic numbers and the sum of inverse
squares.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The Group Law for Elliptic Curves</title>
              <link>https://www.isa-afp.org/entries/Elliptic_Curves_Group_Law.shtml</link>
       <guid>https://www.isa-afp.org/entries/Elliptic_Curves_Group_Law.shtml</guid>
       <dc:creator> Stefan Berghofer       </dc:creator>
       <pubDate>28 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We prove the group law for elliptic curves in Weierstrass form over
fields of characteristic greater than 2. In addition to affine
coordinates, we also formalize projective coordinates, which allow for
more efficient computations. By specializing the abstract
formalization to prime fields, we can apply the curve operations to
parameters used in standard security protocols.</description>
    </item>
    <item>
       <title>Menger's Theorem</title>
              <link>https://www.isa-afp.org/entries/Menger.shtml</link>
       <guid>https://www.isa-afp.org/entries/Menger.shtml</guid>
       <dc:creator> Christoph Dittmann       </dc:creator>
       <pubDate>26 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We present a formalization of Menger&#39;s Theorem for directed and
undirected graphs in Isabelle/HOL.  This well-known result shows that
if two non-adjacent distinct vertices u, v in a directed graph have no
separator smaller than n, then there exist n internally
vertex-disjoint paths from u to v.  The version for undirected graphs
follows immediately because undirected graphs are a special case of
directed graphs.</description>
    </item>
  </channel>
</rss>
