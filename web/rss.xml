<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>15 Jan 2019 00:00:00 +0000</pubDate>
    <item>
       <title>IMP2 – Simple Program Verification in Isabelle/HOL</title>
              <link>https://www.isa-afp.org/entries/IMP2.html</link>
       <guid>https://www.isa-afp.org/entries/IMP2.html</guid>
       <dc:creator> Peter Lammich, Simon Wimmer       </dc:creator>
       <pubDate>15 Jan 2019 00:00:00 +0000</pubDate>
       <description>
IMP2 is a simple imperative language together with Isabelle tooling to
create a program verification environment in Isabelle/HOL. The tools
include a C-like syntax, a verification condition generator, and
Isabelle commands for the specification of programs. The framework is
modular, i.e., it allows easy reuse of already proved programs within
larger programs.  This entry comes with a quickstart guide and a large
collection of examples, spanning basic algorithms with simple proofs
to more advanced algorithms and proof techniques like data refinement.
Some highlights from the examples are: &lt;ul&gt; &lt;li&gt;Bisection
Square Root, &lt;/li&gt; &lt;li&gt;Extended Euclid,  &lt;/li&gt;
&lt;li&gt;Exponentiation by Squaring,  &lt;/li&gt; &lt;li&gt;Binary
Search,  &lt;/li&gt; &lt;li&gt;Insertion Sort,  &lt;/li&gt;
&lt;li&gt;Quicksort,  &lt;/li&gt; &lt;li&gt;Depth First Search.
&lt;/li&gt; &lt;/ul&gt;  The abstract syntax and semantics are very
simple and well-documented. They are suitable to be used in a course,
as extension to the IMP language which comes with the Isabelle
distribution.  While this entry is limited to a simple imperative
language, the ideas could be extended to more sophisticated languages.</description>
    </item>
    <item>
       <title>An Algebra for Higher-Order Terms</title>
              <link>https://www.isa-afp.org/entries/Higher_Order_Terms.html</link>
       <guid>https://www.isa-afp.org/entries/Higher_Order_Terms.html</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>15 Jan 2019 00:00:00 +0000</pubDate>
       <description>
In this formalization, I introduce a higher-order term algebra,
generalizing the notions of free variables, matching, and
substitution. The need arose from the work on a &lt;a
href=&#34;http://dx.doi.org/10.1007/978-3-319-89884-1_35&#34;&gt;verified
compiler from Isabelle to CakeML&lt;/a&gt;. Terms can be thought of as
consisting of a generic (free variables, constants, application) and
a specific part. As example applications, this entry provides
instantiations for de-Bruijn terms, terms with named variables, and
&lt;a
href=&#34;https://www.isa-afp.org/entries/Lambda_Free_RPOs.html&#34;&gt;Blanchette’s
&amp;lambda;-free higher-order terms&lt;/a&gt;. Furthermore, I
implement translation functions between de-Bruijn terms and named
terms and prove their correctness.</description>
    </item>
    <item>
       <title>A Reduction Theorem for Store Buffers</title>
              <link>https://www.isa-afp.org/entries/Store_Buffer_Reduction.html</link>
       <guid>https://www.isa-afp.org/entries/Store_Buffer_Reduction.html</guid>
       <dc:creator> Ernie Cohen, Norbert Schirmer       </dc:creator>
       <pubDate>07 Jan 2019 00:00:00 +0000</pubDate>
       <description>
When verifying a concurrent program, it is usual to assume that memory
is sequentially consistent.  However, most modern multiprocessors
depend on store buffering for efficiency, and provide native
sequential consistency only at a substantial performance penalty.  To
regain sequential consistency, a programmer has to follow an
appropriate programming discipline. However, na&amp;iuml;ve disciplines,
such as protecting all shared accesses with locks, are not flexible
enough for building high-performance multiprocessor software.  We
present a new discipline for concurrent programming under TSO (total
store order, with store buffer forwarding). It does not depend on
concurrency primitives, such as locks. Instead, threads use ghost
operations to acquire and release ownership of memory addresses. A
thread can write to an address only if no other thread owns it, and
can read from an address only if it owns it or it is shared and the
thread has flushed its store buffer since it last wrote to an address
it did not own. This discipline covers both coarse-grained concurrency
(where data is protected by locks) as well as fine-grained concurrency
(where atomic operations race to memory).  We formalize this
discipline in Isabelle/HOL, and prove that if every execution of a
program in a system without store buffers follows the discipline, then
every execution of the program with store buffers is sequentially
consistent. Thus, we can show sequential consistency under TSO by
ordinary assertional reasoning about the program, without having to
consider store buffers at all.</description>
    </item>
    <item>
       <title>A Formal Model of the Document Object Model</title>
              <link>https://www.isa-afp.org/entries/Core_DOM.html</link>
       <guid>https://www.isa-afp.org/entries/Core_DOM.html</guid>
       <dc:creator> Achim D. Brucker, Michael Herzberg       </dc:creator>
       <pubDate>26 Dec 2018 00:00:00 +0000</pubDate>
       <description>
In this AFP entry, we formalize the core of the Document Object Model
(DOM).  At its core, the DOM defines a tree-like data structure for
representing documents in general and HTML documents in particular. It
is the heart of any modern web browser.  Formalizing the key concepts
of the DOM is a prerequisite for the formal reasoning over client-side
JavaScript programs and for the analysis of security concepts in
modern web browsers.  We present a formalization of the core DOM, with
focus on the node-tree and the operations defined on node-trees, in
Isabelle/HOL. We use the formalization to verify the functional
correctness of the most important functions defined in the DOM
standard. Moreover, our formalization is 1) extensible, i.e., can be
extended without the need of re-proving already proven properties and
2) executable, i.e., we can generate executable code from our
specification.</description>
    </item>
    <item>
       <title>Formalization of Concurrent Revisions</title>
              <link>https://www.isa-afp.org/entries/Concurrent_Revisions.html</link>
       <guid>https://www.isa-afp.org/entries/Concurrent_Revisions.html</guid>
       <dc:creator> Roy Overbeek       </dc:creator>
       <pubDate>25 Dec 2018 00:00:00 +0000</pubDate>
       <description>
Concurrent revisions is a concurrency control model developed by
Microsoft Research. It has many interesting properties that
distinguish it from other well-known models such as transactional
memory. One of these properties is &lt;em&gt;determinacy&lt;/em&gt;:
programs written within the model always produce the same outcome,
independent of scheduling activity. The concurrent revisions model has
an operational semantics, with an informal proof of determinacy. This
document contains an Isabelle/HOL formalization of this semantics and
the proof of determinacy.</description>
    </item>
    <item>
       <title>Constructive Cryptography in HOL</title>
              <link>https://www.isa-afp.org/entries/Constructive_Cryptography.html</link>
       <guid>https://www.isa-afp.org/entries/Constructive_Cryptography.html</guid>
       <dc:creator> Andreas Lochbihler, S. Reza Sefidgar       </dc:creator>
       <pubDate>17 Dec 2018 00:00:00 +0000</pubDate>
       <description>
Inspired by Abstract Cryptography, we extend CryptHOL, a framework for
formalizing game-based proofs, with an abstract model of Random
Systems and provide proof rules about their composition and equality.
This foundation facilitates the formalization of Constructive
Cryptography proofs, where the security of a cryptographic scheme is
realized as a special form of construction in which a complex random
system is built from simpler ones. This is a first step towards a
fully-featured compositional framework, similar to Universal
Composability framework, that supports formalization of
simulation-based proofs.</description>
    </item>
    <item>
       <title>Transformer Semantics</title>
              <link>https://www.isa-afp.org/entries/Transformer_Semantics.html</link>
       <guid>https://www.isa-afp.org/entries/Transformer_Semantics.html</guid>
       <dc:creator> Georg Struth       </dc:creator>
       <pubDate>11 Dec 2018 00:00:00 +0000</pubDate>
       <description>
These mathematical components formalise predicate transformer
semantics for programs, yet currently only for partial correctness and
in the absence of faults.  A first part for isotone (or monotone),
Sup-preserving and Inf-preserving transformers follows Back and von
Wright&#39;s approach, with additional emphasis on the quantalic
structure of algebras of transformers.  The second part develops
Sup-preserving and Inf-preserving predicate transformers from the
powerset monad, via its Kleisli category and Eilenberg-Moore algebras,
with emphasis on adjunctions and dualities, as well as isomorphisms
between relations, state transformers and predicate transformers.</description>
    </item>
    <item>
       <title>Quantales</title>
              <link>https://www.isa-afp.org/entries/Quantales.html</link>
       <guid>https://www.isa-afp.org/entries/Quantales.html</guid>
       <dc:creator> Georg Struth       </dc:creator>
       <pubDate>11 Dec 2018 00:00:00 +0000</pubDate>
       <description>
These mathematical components formalise basic properties of quantales,
together with some important models, constructions, and concepts,
including quantic nuclei and conuclei.</description>
    </item>
    <item>
       <title>Properties of Orderings and Lattices</title>
              <link>https://www.isa-afp.org/entries/Order_Lattice_Props.html</link>
       <guid>https://www.isa-afp.org/entries/Order_Lattice_Props.html</guid>
       <dc:creator> Georg Struth       </dc:creator>
       <pubDate>11 Dec 2018 00:00:00 +0000</pubDate>
       <description>
These components add further fundamental order and lattice-theoretic
concepts and properties to Isabelle&#39;s libraries.  They follow by
and large the introductory sections of the Compendium of Continuous
Lattices,  covering directed and filtered sets, down-closed and
up-closed sets, ideals and filters, Galois connections, closure and
co-closure operators. Some emphasis is on duality and morphisms
between structures, as in the Compendium.  To this end, three ad-hoc
approaches to duality are compared.</description>
    </item>
    <item>
       <title>Graph Saturation</title>
              <link>https://www.isa-afp.org/entries/Graph_Saturation.html</link>
       <guid>https://www.isa-afp.org/entries/Graph_Saturation.html</guid>
       <dc:creator> Sebastiaan J. C. Joosten       </dc:creator>
       <pubDate>23 Nov 2018 00:00:00 +0000</pubDate>
       <description>
This is an Isabelle/HOL formalisation of graph saturation, closely
following a &lt;a href=&#34;https://doi.org/10.1016/j.jlamp.2018.06.005&#34;&gt;paper by the author&lt;/a&gt; on graph saturation.
Nine out of ten lemmas of the original paper are proven in this
formalisation. The formalisation additionally includes two theorems
that show the main premise of the paper: that consistency and
entailment are decided through graph saturation. This formalisation
does not give executable code, and it did not implement any of the
optimisations suggested in the paper.</description>
    </item>
    <item>
       <title>A Verified Functional Implementation of Bachmair and Ganzinger's Ordered Resolution Prover</title>
              <link>https://www.isa-afp.org/entries/Functional_Ordered_Resolution_Prover.html</link>
       <guid>https://www.isa-afp.org/entries/Functional_Ordered_Resolution_Prover.html</guid>
       <dc:creator> Anders Schlichtkrull, Jasmin Christian Blanchette, Dmitriy Traytel       </dc:creator>
       <pubDate>23 Nov 2018 00:00:00 +0000</pubDate>
       <description>
This Isabelle/HOL formalization refines the abstract ordered
resolution prover  presented in Section 4.3 of Bachmair and
Ganzinger&#39;s &#34;Resolution Theorem Proving&#34; chapter in the
&lt;i&gt;Handbook of Automated Reasoning&lt;/i&gt;. The result is a
functional implementation of a first-order prover.</description>
    </item>
    <item>
       <title>Auto2 Prover</title>
              <link>https://www.isa-afp.org/entries/Auto2_HOL.html</link>
       <guid>https://www.isa-afp.org/entries/Auto2_HOL.html</guid>
       <dc:creator> Bohua Zhan       </dc:creator>
       <pubDate>20 Nov 2018 00:00:00 +0000</pubDate>
       <description>
Auto2 is a saturation-based heuristic prover for higher-order logic,
implemented as a tactic in Isabelle.  This entry contains the
instantiation of auto2 for Isabelle/HOL, along with two basic
examples: solutions to some of the Pelletier’s problems, and
elementary number theory of primes.</description>
    </item>
    <item>
       <title>Matroids</title>
              <link>https://www.isa-afp.org/entries/Matroids.html</link>
       <guid>https://www.isa-afp.org/entries/Matroids.html</guid>
       <dc:creator> Jonas Keinholz       </dc:creator>
       <pubDate>16 Nov 2018 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article defines the combinatorial structures known as
&lt;em&gt;Independence Systems&lt;/em&gt; and
&lt;em&gt;Matroids&lt;/em&gt; and provides basic concepts and theorems
related to them. These structures play an important role in
combinatorial optimisation, e. g. greedy algorithms such as
Kruskal&#39;s algorithm. The development is based on Oxley&#39;s
&lt;a href=&#34;http://www.math.lsu.edu/~oxley/survey4.pdf&#34;&gt;`What
is a Matroid?&#39;&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Deriving generic class instances for datatypes</title>
              <link>https://www.isa-afp.org/entries/Generic_Deriving.html</link>
       <guid>https://www.isa-afp.org/entries/Generic_Deriving.html</guid>
       <dc:creator> Jonas Rädle, Lars Hupel       </dc:creator>
       <pubDate>06 Nov 2018 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;We provide a framework for automatically deriving instances for
generic type classes. Our approach is inspired by Haskell&#39;s
&lt;i&gt;generic-deriving&lt;/i&gt; package and Scala&#39;s
&lt;i&gt;shapeless&lt;/i&gt; library.  In addition to generating the
code for type class functions, we also attempt to automatically prove
type class laws for these instances. As of now, however, some manual
proofs are still required for recursive datatypes.&lt;/p&gt;
&lt;p&gt;Note: There are already articles in the AFP that provide
automatic instantiation for a number of classes. Concretely, &lt;a href=&#34;https://www.isa-afp.org/entries/Deriving.html&#34;&gt;Deriving&lt;/a&gt; allows the automatic instantiation of comparators, linear orders, equality, and hashing. &lt;a href=&#34;https://www.isa-afp.org/entries/Show.html&#34;&gt;Show&lt;/a&gt; instantiates a Haskell-style &lt;i&gt;show&lt;/i&gt; class.&lt;/p&gt;&lt;p&gt;Our approach works for arbitrary classes (with some Isabelle/HOL overhead for each class), but a smaller set of datatypes.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Formalisation and Evaluation of Alan Gewirth's Proof for the Principle of Generic Consistency in Isabelle/HOL</title>
              <link>https://www.isa-afp.org/entries/GewirthPGCProof.html</link>
       <guid>https://www.isa-afp.org/entries/GewirthPGCProof.html</guid>
       <dc:creator> David Fuenmayor, Christoph Benzmüller       </dc:creator>
       <pubDate>30 Oct 2018 00:00:00 +0000</pubDate>
       <description>
An ambitious ethical theory ---Alan Gewirth&#39;s &#34;Principle of
Generic Consistency&#34;--- is encoded and analysed in Isabelle/HOL.
Gewirth&#39;s theory has stirred much attention in philosophy and
ethics and has been proposed as a potential means to bound the impact
of artificial general intelligence.</description>
    </item>
    <item>
       <title>Epistemic Logic</title>
              <link>https://www.isa-afp.org/entries/Epistemic_Logic.html</link>
       <guid>https://www.isa-afp.org/entries/Epistemic_Logic.html</guid>
       <dc:creator> Andreas Halkjær From       </dc:creator>
       <pubDate>29 Oct 2018 00:00:00 +0000</pubDate>
       <description>
This work is a formalization of epistemic logic with countably many
agents. It includes proofs of soundness and completeness for the axiom
system K. The completeness proof is based on the textbook
&#34;Reasoning About Knowledge&#34; by Fagin, Halpern, Moses and
Vardi (MIT Press 1995).</description>
    </item>
    <item>
       <title>Smooth Manifolds</title>
              <link>https://www.isa-afp.org/entries/Smooth_Manifolds.html</link>
       <guid>https://www.isa-afp.org/entries/Smooth_Manifolds.html</guid>
       <dc:creator> Fabian Immler, Bohua Zhan       </dc:creator>
       <pubDate>22 Oct 2018 00:00:00 +0000</pubDate>
       <description>
We formalize the definition and basic properties of smooth manifolds
in Isabelle/HOL. Concepts covered include partition of unity, tangent
and cotangent spaces, and the fundamental theorem of path integrals.
We also examine some concrete manifolds such as spheres and projective
spaces. The formalization makes extensive use of the analysis and
linear algebra libraries in Isabelle/HOL, in particular its
“types-to-sets” mechanism.</description>
    </item>
    <item>
       <title>Randomised Binary Search Trees</title>
              <link>https://www.isa-afp.org/entries/Randomised_BSTs.html</link>
       <guid>https://www.isa-afp.org/entries/Randomised_BSTs.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>19 Oct 2018 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This work is a formalisation of the Randomised Binary Search
Trees introduced by Martínez and Roura, including definitions and
correctness proofs.&lt;/p&gt; &lt;p&gt;Like randomised treaps, they
are a probabilistic data structure that behaves exactly as if elements
were inserted into a non-balancing BST in random order. However,
unlike treaps, they only use discrete probability distributions, but
their use of randomness is more complicated.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Formalization of the Embedding Path Order for Lambda-Free Higher-Order Terms</title>
              <link>https://www.isa-afp.org/entries/Lambda_Free_EPO.html</link>
       <guid>https://www.isa-afp.org/entries/Lambda_Free_EPO.html</guid>
       <dc:creator> Alexander Bentkamp       </dc:creator>
       <pubDate>19 Oct 2018 00:00:00 +0000</pubDate>
       <description>
This Isabelle/HOL formalization defines the Embedding Path Order (EPO)
for higher-order terms without lambda-abstraction and proves many
useful properties about it. In contrast to the lambda-free recursive
path orders, it does not fully coincide with RPO on first-order terms,
but it is compatible with arbitrary higher-order contexts.</description>
    </item>
    <item>
       <title>Upper Bounding Diameters of State Spaces of Factored Transition Systems</title>
              <link>https://www.isa-afp.org/entries/Factored_Transition_System_Bounding.html</link>
       <guid>https://www.isa-afp.org/entries/Factored_Transition_System_Bounding.html</guid>
       <dc:creator> Friedrich Kurz, Mohammad Abdulaziz       </dc:creator>
       <pubDate>12 Oct 2018 00:00:00 +0000</pubDate>
       <description>
A completeness threshold is required to guarantee the completeness of
planning as satisfiability, and bounded model checking of safety
properties. One valid completeness threshold is the diameter of the
underlying transition system. The diameter is the maximum element in
the set of lengths of all shortest paths between pairs of states. The
diameter is not calculated exactly in our setting, where the
transition system is succinctly described using a (propositionally)
factored representation. Rather, an upper bound on the diameter is
calculated compositionally, by bounding the diameters of small
abstract subsystems, and then composing those.  We port a HOL4
formalisation of a compositional algorithm for computing a relatively
tight upper bound on the system diameter. This compositional algorithm
exploits acyclicity in the state space to achieve compositionality,
and it was introduced by Abdulaziz et. al. The formalisation that we
port is described as a part of another paper by Abdulaziz et. al. As a
part of this porting we developed a libray about transition systems,
which shall be of use in future related mechanisation efforts.</description>
    </item>
    <item>
       <title>The Transcendence of π</title>
              <link>https://www.isa-afp.org/entries/Pi_Transcendental.html</link>
       <guid>https://www.isa-afp.org/entries/Pi_Transcendental.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>28 Sep 2018 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry shows the transcendence of &amp;pi; based on the
classic proof using the fundamental theorem of symmetric polynomials
first given by von Lindemann in 1882, but the formalisation mostly
follows the version by Niven. The proof reuses much of the machinery
developed in the AFP entry on the transcendence of
&lt;em&gt;e&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Symmetric Polynomials</title>
              <link>https://www.isa-afp.org/entries/Symmetric_Polynomials.html</link>
       <guid>https://www.isa-afp.org/entries/Symmetric_Polynomials.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>25 Sep 2018 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;A symmetric polynomial is a polynomial in variables
&lt;em&gt;X&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,&lt;em&gt;X&lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt;
that does not discriminate between its variables, i.&amp;thinsp;e. it
is invariant under any permutation of them. These polynomials are
important in the study of the relationship between the coefficients of
a univariate polynomial and its roots in its algebraic
closure.&lt;/p&gt; &lt;p&gt;This article provides a definition of
symmetric polynomials and the elementary symmetric polynomials
e&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,e&lt;sub&gt;n&lt;/sub&gt; and
proofs of their basic properties, including three notable
ones:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; Vieta&#39;s formula, which
gives an explicit expression for the &lt;em&gt;k&lt;/em&gt;-th
coefficient of a univariate monic polynomial in terms of its roots
&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt;,
namely
&lt;em&gt;c&lt;/em&gt;&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt; = (-1)&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;-&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;&amp;thinsp;e&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;-&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;(&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;n&lt;/sub&gt;).&lt;/li&gt;
&lt;li&gt;Second, the Fundamental Theorem of Symmetric Polynomials,
which states that any symmetric polynomial is itself a uniquely
determined polynomial combination of the elementary symmetric
polynomials.&lt;/li&gt; &lt;li&gt;Third, as a corollary of the
previous two, that given a polynomial over some ring
&lt;em&gt;R&lt;/em&gt;, any symmetric polynomial combination of its
roots is also in &lt;em&gt;R&lt;/em&gt; even when the roots are not.
&lt;/ul&gt; &lt;p&gt; Both the symmetry property itself and the
witness for the Fundamental Theorem are executable. &lt;/p&gt;</description>
    </item>
    <item>
       <title>Signature-Based Gröbner Basis Algorithms</title>
              <link>https://www.isa-afp.org/entries/Signature_Groebner.html</link>
       <guid>https://www.isa-afp.org/entries/Signature_Groebner.html</guid>
       <dc:creator> Alexander Maletzky       </dc:creator>
       <pubDate>20 Sep 2018 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article formalizes signature-based algorithms for computing
Gr&amp;ouml;bner bases. Such algorithms are, in general, superior to
other algorithms in terms of efficiency, and have not been formalized
in any proof assistant so far. The present development is both
generic, in the sense that most known variants of signature-based
algorithms are covered by it, and effectively executable on concrete
input thanks to Isabelle&#39;s code generator. Sample computations of
benchmark problems show that the verified implementation of
signature-based algorithms indeed outperforms the existing
implementation of Buchberger&#39;s algorithm in Isabelle/HOL.&lt;/p&gt;
&lt;p&gt;Besides total correctness of the algorithms, the article also proves
that under certain conditions they a-priori detect and avoid all
useless zero-reductions, and always return &#39;minimal&#39; (in
some sense) Gr&amp;ouml;bner bases if an input parameter is chosen in
the right way.&lt;/p&gt;&lt;p&gt;The formalization follows the recent survey article by
Eder and Faug&amp;egrave;re.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The Prime Number Theorem</title>
              <link>https://www.isa-afp.org/entries/Prime_Number_Theorem.html</link>
       <guid>https://www.isa-afp.org/entries/Prime_Number_Theorem.html</guid>
       <dc:creator> Manuel Eberl, Lawrence C. Paulson       </dc:creator>
       <pubDate>19 Sep 2018 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article provides a short proof of the Prime Number
Theorem in several equivalent forms, most notably
&amp;pi;(&lt;em&gt;x&lt;/em&gt;) ~ &lt;em&gt;x&lt;/em&gt;/ln
&lt;em&gt;x&lt;/em&gt; where &amp;pi;(&lt;em&gt;x&lt;/em&gt;) is the
number of primes no larger than &lt;em&gt;x&lt;/em&gt;. It also
defines other basic number-theoretic functions related to primes like
Chebyshev&#39;s functions &amp;thetasym; and &amp;psi; and the
&amp;ldquo;&lt;em&gt;n&lt;/em&gt;-th prime number&amp;rdquo; function
p&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt;. We also show various
bounds and relationship between these functions are shown. Lastly, we
derive Mertens&#39; First and Second Theorem, i.&amp;thinsp;e.
&amp;sum;&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&amp;le;&lt;em&gt;x&lt;/em&gt;&lt;/sub&gt;
ln &lt;em&gt;p&lt;/em&gt;/&lt;em&gt;p&lt;/em&gt; = ln
&lt;em&gt;x&lt;/em&gt; + &lt;em&gt;O&lt;/em&gt;(1) and
&amp;sum;&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&amp;le;&lt;em&gt;x&lt;/em&gt;&lt;/sub&gt;
1/&lt;em&gt;p&lt;/em&gt; = ln ln &lt;em&gt;x&lt;/em&gt; + M +
&lt;em&gt;O&lt;/em&gt;(1/ln &lt;em&gt;x&lt;/em&gt;). We also give
explicit bounds for the remainder terms.&lt;/p&gt; &lt;p&gt;The proof
of the Prime Number Theorem builds on a library of Dirichlet series
and analytic combinatorics. We essentially follow the presentation by
Newman. The core part of the proof is a Tauberian theorem for
Dirichlet series, which is proven using complex analysis and then used
to strengthen Mertens&#39; First Theorem to
&amp;sum;&lt;sub&gt;&lt;em&gt;p&lt;/em&gt;&amp;le;&lt;em&gt;x&lt;/em&gt;&lt;/sub&gt;
ln &lt;em&gt;p&lt;/em&gt;/&lt;em&gt;p&lt;/em&gt; = ln
&lt;em&gt;x&lt;/em&gt; + c + &lt;em&gt;o&lt;/em&gt;(1).&lt;/p&gt;
&lt;p&gt;A variant of this proof has been formalised before by
Harrison in HOL Light, and formalisations of Selberg&#39;s elementary
proof exist both by Avigad &lt;em&gt;et al.&lt;/em&gt; in Isabelle and
by Carneiro in Metamath. The advantage of the analytic proof is that,
while it requires more powerful mathematical tools, it is considerably
shorter and clearer. This article attempts to provide a short and
clear formalisation of all components of that proof using the full
range of mathematical machinery available in Isabelle, staying as
close as possible to Newman&#39;s simple paper proof.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Aggregation Algebras</title>
              <link>https://www.isa-afp.org/entries/Aggregation_Algebras.html</link>
       <guid>https://www.isa-afp.org/entries/Aggregation_Algebras.html</guid>
       <dc:creator> Walter Guttmann       </dc:creator>
       <pubDate>15 Sep 2018 00:00:00 +0000</pubDate>
       <description>
We develop algebras for aggregation and minimisation for weight
matrices and for edge weights in graphs. We verify the correctness of
Prim&#39;s and Kruskal&#39;s minimum spanning tree algorithms based
on these algebras. We also show numerous instances of these algebras
based on linearly ordered commutative semigroups.</description>
    </item>
    <item>
       <title>Octonions</title>
              <link>https://www.isa-afp.org/entries/Octonions.html</link>
       <guid>https://www.isa-afp.org/entries/Octonions.html</guid>
       <dc:creator> Angeliki Koutsoukou-Argyraki       </dc:creator>
       <pubDate>14 Sep 2018 00:00:00 +0000</pubDate>
       <description>
We develop the basic theory of Octonions, including various identities
and properties of the octonions and of the octonionic product, a
description of 7D isometries and representations of orthogonal
transformations. To this end we first develop the theory of the vector
cross product in 7 dimensions. The development of the theory of
Octonions is inspired by that of the theory of Quaternions by Lawrence
Paulson. However, we do not work within the type class real_algebra_1
because the octonionic product is not associative.</description>
    </item>
    <item>
       <title>Quaternions</title>
              <link>https://www.isa-afp.org/entries/Quaternions.html</link>
       <guid>https://www.isa-afp.org/entries/Quaternions.html</guid>
       <dc:creator> Lawrence C. Paulson       </dc:creator>
       <pubDate>05 Sep 2018 00:00:00 +0000</pubDate>
       <description>
This theory is inspired by the HOL Light development of quaternions,
but follows its own route. Quaternions are developed coinductively, as
in the existing formalisation of the complex numbers. Quaternions are
quickly shown to belong to the type classes of real normed division
algebras and real inner product spaces. And therefore they inherit a
great body of facts involving algebraic  laws, limits, continuity,
etc., which must be proved explicitly in the HOL Light version.  The
development concludes with the geometric interpretation of the product
of imaginary quaternions.</description>
    </item>
    <item>
       <title>The Budan-Fourier Theorem and Counting Real Roots with Multiplicity</title>
              <link>https://www.isa-afp.org/entries/Budan_Fourier.html</link>
       <guid>https://www.isa-afp.org/entries/Budan_Fourier.html</guid>
       <dc:creator> Wenda Li       </dc:creator>
       <pubDate>02 Sep 2018 00:00:00 +0000</pubDate>
       <description>
This entry is mainly about counting and approximating real roots (of a
polynomial) with multiplicity. We have first formalised the
Budan-Fourier theorem: given a polynomial with real coefficients, we
can calculate sign variations on Fourier sequences to over-approximate
the number of real roots (counting multiplicity) within an interval.
When all roots are known to be real, the over-approximation becomes
tight: we can utilise this theorem to count real roots exactly. It is
also worth noting that Descartes&#39; rule of sign is a direct
consequence of the Budan-Fourier theorem, and has been included in
this entry. In addition, we have extended previous formalised
Sturm&#39;s theorem to count real roots with multiplicity, while the
original Sturm&#39;s theorem only counts distinct real roots.
Compared to the Budan-Fourier theorem, our extended Sturm&#39;s
theorem always counts roots exactly but may suffer from greater
computational cost.</description>
    </item>
    <item>
       <title>An Incremental Simplex Algorithm with Unsatisfiable Core Generation</title>
              <link>https://www.isa-afp.org/entries/Simplex.html</link>
       <guid>https://www.isa-afp.org/entries/Simplex.html</guid>
       <dc:creator> Filip Marić, Mirko Spasić, René Thiemann       </dc:creator>
       <pubDate>24 Aug 2018 00:00:00 +0000</pubDate>
       <description>
We present an Isabelle/HOL formalization and total correctness proof
for the incremental version of the Simplex algorithm which is used in
most state-of-the-art SMT solvers. It supports extraction of
satisfying assignments, extraction of unsatisfiable cores, incremental
assertion of constraints and backtracking. The formalization relies on
stepwise program refinement, starting from a simple specification,
going through a number of refinement steps, and ending up in a fully
executable functional implementation. Symmetries present in the
algorithm are handled with special care.</description>
    </item>
    <item>
       <title>Minsky Machines</title>
              <link>https://www.isa-afp.org/entries/Minsky_Machines.html</link>
       <guid>https://www.isa-afp.org/entries/Minsky_Machines.html</guid>
       <dc:creator> Bertram Felgenhauer       </dc:creator>
       <pubDate>14 Aug 2018 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt; We formalize undecidablity results for Minsky machines. To
this end, we also formalize recursive inseparability.
&lt;/p&gt;&lt;p&gt; We start by proving that Minsky machines can
compute arbitrary primitive recursive and recursive functions. We then
show that there is a deterministic Minsky machine with one argument
and two final states such that the set of inputs that are accepted in
one state is recursively inseparable from the set of inputs that are
accepted in the other state. &lt;/p&gt;&lt;p&gt; As a corollary, the
set of Minsky configurations that reach the first state but not the
second recursively inseparable from the set of Minsky configurations
that reach the second state but not the first. In particular both
these sets are undecidable. &lt;/p&gt;&lt;p&gt; We do
&lt;em&gt;not&lt;/em&gt; prove that recursive functions can simulate
Minsky machines. &lt;/p&gt;</description>
    </item>
  </channel>
</rss>
