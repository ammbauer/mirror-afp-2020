<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>06 Apr 2017 00:00:00 +0000</pubDate>
    <item>
       <title>Subresultants</title>
              <link>https://www.isa-afp.org/entries/Subresultants.shtml</link>
       <guid>https://www.isa-afp.org/entries/Subresultants.shtml</guid>
       <dc:creator> Sebastiaan Joosten, René Thiemann, Akihisa Yamada       </dc:creator>
       <pubDate>06 Apr 2017 00:00:00 +0000</pubDate>
       <description>
We formalize the theory of subresultants and the subresultant
polynomial remainder sequence as described by Brown and Traub. As a
result, we obtain efficient certified algorithms for computing the
resultant and the greatest common divisor of polynomials.</description>
    </item>
    <item>
       <title>Expected Shape of Random Binary Search Trees</title>
              <link>https://www.isa-afp.org/entries/Random_BSTs.shtml</link>
       <guid>https://www.isa-afp.org/entries/Random_BSTs.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>04 Apr 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry contains proofs for the textbook results about the
distributions of the height and internal path length of random binary
search trees (BSTs), i.&amp;thinsp;e. BSTs that are formed by taking
an empty BST and inserting elements from a fixed set in random
order.&lt;/p&gt;  &lt;p&gt;In particular, we prove a logarithmic upper
bound on the expected height and the &lt;em&gt;Θ(n log n)&lt;/em&gt;
closed-form solution for the expected internal path length in terms of
the harmonic numbers. We also show how the internal path length
relates to the average-case cost of a lookup in a BST.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The number of comparisons in QuickSort</title>
              <link>https://www.isa-afp.org/entries/Quick_Sort_Cost.shtml</link>
       <guid>https://www.isa-afp.org/entries/Quick_Sort_Cost.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>15 Mar 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;We give a formal proof of the well-known results about the
number of comparisons performed by two variants of QuickSort: first,
the expected number of comparisons of randomised QuickSort
(i.&amp;thinsp;e.&amp;nbsp;QuickSort with random pivot choice) is
&lt;em&gt;2&amp;thinsp;(n+1)&amp;thinsp;H&lt;sub&gt;n&lt;/sub&gt; -
4&amp;thinsp;n&lt;/em&gt;, which is asymptotically equivalent to
&lt;em&gt;2&amp;thinsp;n ln n&lt;/em&gt;; second, the number of
comparisons performed by the classic non-randomised QuickSort has the
same distribution in the average case as the randomised one.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Lower bound on comparison-based sorting algorithms</title>
              <link>https://www.isa-afp.org/entries/Comparison_Sort_Lower_Bound.shtml</link>
       <guid>https://www.isa-afp.org/entries/Comparison_Sort_Lower_Bound.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>15 Mar 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article contains a formal proof of the well-known fact
that number of comparisons that a comparison-based sorting algorithm
needs to perform to sort a list of length &lt;em&gt;n&lt;/em&gt; is at
least &lt;em&gt;log&lt;sub&gt;2&lt;/sub&gt;&amp;nbsp;(n!)&lt;/em&gt;
in the worst case, i.&amp;thinsp;e.&amp;nbsp;&lt;em&gt;Ω(n log
n)&lt;/em&gt;.&lt;/p&gt;  &lt;p&gt;For this purpose, a shallow
embedding for comparison-based sorting algorithms is defined: a
sorting algorithm is a recursive datatype containing either a HOL
function or a query of a comparison oracle with a continuation
containing the remaining computation. This makes it possible to force
the algorithm to use only comparisons and to track the number of
comparisons made.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The Euler–MacLaurin Formula</title>
              <link>https://www.isa-afp.org/entries/Euler_MacLaurin.shtml</link>
       <guid>https://www.isa-afp.org/entries/Euler_MacLaurin.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>10 Mar 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The Euler-MacLaurin formula relates the value of a
discrete sum to that of the corresponding integral in terms of the
derivatives at the borders of the summation and a remainder term.
Since the remainder term is often very small as the summation bounds
grow, this can be used to compute asymptotic expansions for
sums.&lt;/p&gt;  &lt;p&gt;This entry contains a proof of this formula
for functions from the reals to an arbitrary Banach space. Two
variants of the formula are given: the standard textbook version and a
variant outlined in &lt;em&gt;Concrete Mathematics&lt;/em&gt; that is
more useful for deriving asymptotic estimates.&lt;/p&gt;  &lt;p&gt;As
example applications, we use that formula to derive the full
asymptotic expansion of the harmonic numbers and the sum of inverse
squares.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The Group Law for Elliptic Curves</title>
              <link>https://www.isa-afp.org/entries/Elliptic_Curves_Group_Law.shtml</link>
       <guid>https://www.isa-afp.org/entries/Elliptic_Curves_Group_Law.shtml</guid>
       <dc:creator> Stefan Berghofer       </dc:creator>
       <pubDate>28 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We prove the group law for elliptic curves in Weierstrass form over
fields of characteristic greater than 2. In addition to affine
coordinates, we also formalize projective coordinates, which allow for
more efficient computations. By specializing the abstract
formalization to prime fields, we can apply the curve operations to
parameters used in standard security protocols.</description>
    </item>
    <item>
       <title>Menger's Theorem</title>
              <link>https://www.isa-afp.org/entries/Menger.shtml</link>
       <guid>https://www.isa-afp.org/entries/Menger.shtml</guid>
       <dc:creator> Christoph Dittmann       </dc:creator>
       <pubDate>26 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We present a formalization of Menger&#39;s Theorem for directed and
undirected graphs in Isabelle/HOL.  This well-known result shows that
if two non-adjacent distinct vertices u, v in a directed graph have no
separator smaller than n, then there exist n internally
vertex-disjoint paths from u to v.  The version for undirected graphs
follows immediately because undirected graphs are a special case of
directed graphs.</description>
    </item>
    <item>
       <title>Differential Dynamic Logic</title>
              <link>https://www.isa-afp.org/entries/Differential_Dynamic_Logic.shtml</link>
       <guid>https://www.isa-afp.org/entries/Differential_Dynamic_Logic.shtml</guid>
       <dc:creator> Brandon Bohrer       </dc:creator>
       <pubDate>13 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We formalize differential dynamic logic, a logic for proving
properties of hybrid systems. The proof calculus in this formalization
is based on the uniform substitution principle. We show it is sound
with respect to our denotational semantics, which provides increased
confidence in the correctness of the KeYmaera X theorem prover based
on this calculus. As an application, we include a proof term checker
embedded in Isabelle/HOL with several example proofs.  Published in:
Brandon Bohrer, Vincent Rahli, Ivana Vukotic, Marcus Völp, André
Platzer: Formally verified differential dynamic logic. CPP 2017.</description>
    </item>
    <item>
       <title>Abstract Soundness</title>
              <link>https://www.isa-afp.org/entries/Abstract_Soundness.shtml</link>
       <guid>https://www.isa-afp.org/entries/Abstract_Soundness.shtml</guid>
       <dc:creator> Jasmin Christian Blanchette, Andrei Popescu, Dmitriy Traytel       </dc:creator>
       <pubDate>10 Feb 2017 00:00:00 +0000</pubDate>
       <description>
A formalized coinductive account of the abstract development of
Brotherston, Gorogiannis, and Petersen [APLAS 2012], in a slightly
more general form since we work with arbitrary infinite proofs, which
may be acyclic. This work is described in detail in an article by the
authors, published in 2017 in the &lt;em&gt;Journal of Automated
Reasoning&lt;/em&gt;. The abstract proof can be instantiated for
various formalisms, including first-order logic with inductive
predicates.</description>
    </item>
    <item>
       <title>Stone Relation Algebras</title>
              <link>https://www.isa-afp.org/entries/Stone_Relation_Algebras.shtml</link>
       <guid>https://www.isa-afp.org/entries/Stone_Relation_Algebras.shtml</guid>
       <dc:creator> Walter Guttmann       </dc:creator>
       <pubDate>07 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We develop Stone relation algebras, which generalise relation algebras
by replacing the underlying Boolean algebra structure with a Stone
algebra. We show that finite matrices over extended real numbers form
an instance. As a consequence, relation-algebraic concepts and methods
can be used for reasoning about weighted graphs. We also develop a
fixpoint calculus and apply it to compare different definitions of
reflexive-transitive closures in semirings.</description>
    </item>
    <item>
       <title>Refining Authenticated Key Agreement with Strong Adversaries</title>
              <link>https://www.isa-afp.org/entries/Key_Agreement_Strong_Adversaries.shtml</link>
       <guid>https://www.isa-afp.org/entries/Key_Agreement_Strong_Adversaries.shtml</guid>
       <dc:creator> Joseph Lallemand, Christoph Sprenger       </dc:creator>
       <pubDate>31 Jan 2017 00:00:00 +0000</pubDate>
       <description>
We develop a family of key agreement protocols that are correct by
construction. Our work substantially extends prior work on developing
security protocols by refinement. First, we strengthen the adversary
by allowing him to compromise different resources of protocol
participants, such as their long-term keys or their session keys. This
enables the systematic development of protocols that ensure strong
properties such as perfect forward secrecy. Second, we broaden the
class of protocols supported to include those with non-atomic keys and
equationally defined cryptographic operators. We use these extensions
to develop key agreement protocols including signed Diffie-Hellman and
the core of IKEv1 and SKEME.</description>
    </item>
    <item>
       <title>Bernoulli Numbers</title>
              <link>https://www.isa-afp.org/entries/Bernoulli.shtml</link>
       <guid>https://www.isa-afp.org/entries/Bernoulli.shtml</guid>
       <dc:creator> Lukas Bulwahn, Manuel Eberl       </dc:creator>
       <pubDate>24 Jan 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;Bernoulli numbers were first discovered in the closed-form
expansion of the sum 1&lt;sup&gt;m&lt;/sup&gt; +
2&lt;sup&gt;m&lt;/sup&gt; + &amp;hellip; + n&lt;sup&gt;m&lt;/sup&gt;
for a fixed m and appear in many other places. This entry provides
three different definitions for them: a recursive one, an explicit
one, and one through their exponential generating function.&lt;/p&gt;
&lt;p&gt;In addition, we prove some basic facts, e.g. their relation
to sums of powers of integers and that all odd Bernoulli numbers
except the first are zero. We also prove the correctness of the
Akiyama&amp;ndash;Tanigawa algorithm for computing Bernoulli numbers
with reasonable efficiency, and we define the periodic Bernoulli
polynomials (which appear e.g. in the Euler&amp;ndash;MacLaurin
summation formula and the expansion of the log-Gamma function) and
prove their basic properties.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Minimal Static Single Assignment Form</title>
              <link>https://www.isa-afp.org/entries/Minimal_SSA.shtml</link>
       <guid>https://www.isa-afp.org/entries/Minimal_SSA.shtml</guid>
       <dc:creator> Max Wagner, Denis Lohner       </dc:creator>
       <pubDate>17 Jan 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This formalization is an extension to &lt;a
href=&#34;https://www.isa-afp.org/entries/Formal_SSA.shtml&#34;&gt;&#34;Verified
Construction of Static Single Assignment Form&#34;&lt;/a&gt;. In
their work, the authors have shown that &lt;a
href=&#34;http://dx.doi.org/10.1007/978-3-642-37051-9_6&#34;&gt;Braun
et al.&#39;s static single assignment (SSA) construction
algorithm&lt;/a&gt; produces minimal SSA form for input programs with
a reducible control flow graph (CFG). However Braun et al. also
proposed an extension to their algorithm that they claim produces
minimal SSA form even for irreducible CFGs.&lt;br&gt; In this
formalization we support that claim by giving a mechanized proof.
&lt;/p&gt;
&lt;p&gt;As the extension of Braun et al.&#39;s algorithm
aims for removing so-called redundant strongly connected components of
phi functions, we show that this suffices to guarantee minimality
according to &lt;a href=&#34;http://dx.doi.org/10.1145/115372.115320&#34;&gt;Cytron et
al.&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Bertrand's postulate</title>
              <link>https://www.isa-afp.org/entries/Bertrands_Postulate.shtml</link>
       <guid>https://www.isa-afp.org/entries/Bertrands_Postulate.shtml</guid>
       <dc:creator> Julian Biendarra, Manuel Eberl       </dc:creator>
       <pubDate>17 Jan 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;Bertrand&#39;s postulate is an early result on the
distribution of prime numbers: For every positive integer n, there
exists a prime number that lies strictly between n and 2n.
The proof is ported from John Harrison&#39;s formalisation
in HOL Light. It proceeds by first showing that the property is true
for all n greater than or equal to 600 and then showing that it also
holds for all n below 600 by case distinction. &lt;/p&gt;</description>
    </item>
    <item>
       <title>The Transcendence of e</title>
              <link>https://www.isa-afp.org/entries/E_Transcendental.shtml</link>
       <guid>https://www.isa-afp.org/entries/E_Transcendental.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>12 Jan 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This work contains a proof that Euler&#39;s number e is transcendental. The
proof follows the standard approach of assuming that e is algebraic and
then using a specific integer polynomial to derive two inconsistent bounds,
leading to a contradiction.&lt;/p&gt; &lt;p&gt;This kind of approach can be found in
many different sources; this formalisation mostly follows a &lt;a  href=&#34;http://planetmath.org/proofoflindemannweierstrasstheoremandthateandpiaretranscendental&#34;&gt;PlanetMath article&lt;/a&gt; by Roger Lipsett.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Formal Network Models and Their Application to Firewall Policies</title>
              <link>https://www.isa-afp.org/entries/UPF_Firewall.shtml</link>
       <guid>https://www.isa-afp.org/entries/UPF_Firewall.shtml</guid>
       <dc:creator> Achim D. Brucker, Lukas Brügger, Burkhart Wolff       </dc:creator>
       <pubDate>08 Jan 2017 00:00:00 +0000</pubDate>
       <description>
We present a formal model of network protocols and their application
to modeling firewall policies. The formalization is based on the
Unified Policy Framework (UPF). The formalization was originally
developed with for generating test cases for testing the security
configuration actual firewall and router (middle-boxes) using
HOL-TestGen. Our work focuses on modeling application level protocols
on top of tcp/ip.</description>
    </item>
    <item>
       <title>Verification of a Diffie-Hellman Password-based Authentication Protocol by Extending the Inductive Method</title>
              <link>https://www.isa-afp.org/entries/Password_Authentication_Protocol.shtml</link>
       <guid>https://www.isa-afp.org/entries/Password_Authentication_Protocol.shtml</guid>
       <dc:creator> Pasquale Noce       </dc:creator>
       <pubDate>03 Jan 2017 00:00:00 +0000</pubDate>
       <description>
This paper constructs a formal model of a Diffie-Hellman
password-based authentication protocol between a user and a smart
card, and proves its security. The protocol provides for the dispatch
of the user&#39;s password to the smart card on a secure messaging
channel established by means of Password Authenticated Connection
Establishment (PACE), where the mapping method being used is Chip
Authentication Mapping. By applying and suitably extending
Paulson&#39;s Inductive Method, this paper proves that the protocol
establishes trustworthy secure messaging channels, preserves the
secrecy of users&#39; passwords, and provides an effective mutual
authentication service. What is more, these security properties turn
out to hold independently of the secrecy of the PACE authentication
key.</description>
    </item>
    <item>
       <title>First-Order Logic According to Harrison</title>
              <link>https://www.isa-afp.org/entries/FOL_Harrison.shtml</link>
       <guid>https://www.isa-afp.org/entries/FOL_Harrison.shtml</guid>
       <dc:creator> Alexander Birch Jensen, Anders Schlichtkrull, Jørgen Villadsen       </dc:creator>
       <pubDate>01 Jan 2017 00:00:00 +0000</pubDate>
       <description>
We present a certified declarative first-order prover with equality
based on John Harrison&#39;s Handbook of Practical Logic and
Automated Reasoning, Cambridge University Press, 2009. ML code
reflection is used such that the entire prover can be executed within
Isabelle as a very simple interactive proof assistant. As examples we
consider Pelletier&#39;s problems 1-46.</description>
    </item>
    <item>
       <title>Concurrent Refinement Algebra and Rely Quotients</title>
              <link>https://www.isa-afp.org/entries/Concurrent_Ref_Alg.shtml</link>
       <guid>https://www.isa-afp.org/entries/Concurrent_Ref_Alg.shtml</guid>
       <dc:creator> Julian Fell, Ian Hayes, Andrius Velykis       </dc:creator>
       <pubDate>30 Dec 2016 00:00:00 +0000</pubDate>
       <description>
The concurrent refinement algebra developed here is designed to
provide a foundation for rely/guarantee reasoning about concurrent
programs. The algebra builds on a complete lattice of commands by
providing sequential composition, parallel composition and a novel
weak conjunction operator. The weak conjunction operator coincides
with the lattice supremum providing its arguments are non-aborting,
but aborts if either of its arguments do. Weak conjunction provides an
abstract version of a guarantee condition as a guarantee process. We
distinguish between models that distribute sequential composition over
non-deterministic choice from the left (referred to as being
conjunctive in the refinement calculus literature) and those that
don&#39;t. Least and greatest fixed points of monotone functions are
provided to allow recursion and iteration operators to be added to the
language. Additional iteration laws are available for conjunctive
models. The rely quotient of processes &lt;i&gt;c&lt;/i&gt; and
&lt;i&gt;i&lt;/i&gt; is the process that, if executed in parallel with
&lt;i&gt;i&lt;/i&gt; implements &lt;i&gt;c&lt;/i&gt;. It represents an
abstract version of a rely condition generalised to a process.</description>
    </item>
    <item>
       <title>The Twelvefold Way</title>
              <link>https://www.isa-afp.org/entries/Twelvefold_Way.shtml</link>
       <guid>https://www.isa-afp.org/entries/Twelvefold_Way.shtml</guid>
       <dc:creator> Lukas Bulwahn       </dc:creator>
       <pubDate>29 Dec 2016 00:00:00 +0000</pubDate>
       <description>
This entry provides all cardinality theorems of the Twelvefold Way.
The Twelvefold Way systematically classifies twelve related
combinatorial problems concerning two finite sets, which include
counting permutations, combinations, multisets, set partitions and
number partitions. This development builds upon the existing formal
developments with cardinality theorems for those structures. It
provides twelve bijections from the various structures to different
equivalence classes on finite functions, and hence, proves cardinality
formulae for these equivalence classes on finite functions.</description>
    </item>
    <item>
       <title>Proof Strategy Language</title>
              <link>https://www.isa-afp.org/entries/Proof_Strategy_Language.shtml</link>
       <guid>https://www.isa-afp.org/entries/Proof_Strategy_Language.shtml</guid>
       <dc:creator> Yutaka Nagashima       </dc:creator>
       <pubDate>20 Dec 2016 00:00:00 +0000</pubDate>
       <description>
Isabelle includes various automatic tools for finding proofs under
certain conditions. However, for each conjecture, knowing which
automation to use, and how to tweak its parameters, is currently
labour intensive. We have developed a language, PSL, designed to
capture high level proof strategies. PSL offloads the construction of
human-readable fast-to-replay proof scripts to automatic search,
making use of search-time information about each conjecture. Our
preliminary evaluations show that PSL reduces the labour cost of
interactive theorem proving. This submission contains the
implementation of PSL and an example theory file, Example.thy, showing
how to write poof strategies in PSL.</description>
    </item>
    <item>
       <title>Paraconsistency</title>
              <link>https://www.isa-afp.org/entries/Paraconsistency.shtml</link>
       <guid>https://www.isa-afp.org/entries/Paraconsistency.shtml</guid>
       <dc:creator> Anders Schlichtkrull, Jørgen Villadsen       </dc:creator>
       <pubDate>07 Dec 2016 00:00:00 +0000</pubDate>
       <description>
Paraconsistency is about handling inconsistency in a coherent way. In
classical and intuitionistic logic everything follows from an
inconsistent theory. A paraconsistent logic avoids the explosion.
Quite a few applications in computer science and engineering are
discussed in the Intelligent Systems Reference Library Volume 110:
Towards Paraconsistent Engineering (Springer 2016). We formalize a
paraconsistent many-valued logic that we motivated and described in a
special issue on logical approaches to paraconsistency (Journal of
Applied Non-Classical Logics 2005). We limit ourselves to the
propositional fragment of the higher-order logic. The logic is based
on so-called key equalities and has a countably infinite number of
truth values. We prove theorems in the logic using the definition of
validity. We verify truth tables and also counterexamples for
non-theorems. We prove meta-theorems about the logic and finally we
investigate a case study.</description>
    </item>
    <item>
       <title>COMPLX: A Verification Framework for Concurrent Imperative Programs</title>
              <link>https://www.isa-afp.org/entries/Complx.shtml</link>
       <guid>https://www.isa-afp.org/entries/Complx.shtml</guid>
       <dc:creator> Sidney Amani, June Andronick, Maksym Bortin, Corey Lewis, Christine Rizkallah, Joseph Tuong       </dc:creator>
       <pubDate>29 Nov 2016 00:00:00 +0000</pubDate>
       <description>
We propose a concurrency reasoning framework for imperative programs,
based on the Owicki-Gries (OG) foundational shared-variable
concurrency method. Our framework combines the approaches of
Hoare-Parallel, a formalisation of OG in Isabelle/HOL for a simple
while-language, and Simpl, a generic imperative language embedded in
Isabelle/HOL, allowing formal reasoning on C programs. We define the
Complx language, extending the syntax and semantics of Simpl with
support for parallel composition and synchronisation. We additionally
define an OG logic, which we prove sound w.r.t. the  semantics, and a
verification condition generator, both supporting involved low-level
imperative constructs such as function calls and abrupt termination.
We illustrate our framework on an example that features exceptions,
guards and function calls.  We aim to then target concurrent operating
systems, such as the interruptible eChronos embedded operating system
for which we already have a model-level OG proof using Hoare-Parallel.</description>
    </item>
    <item>
       <title>Abstract Interpretation of Annotated Commands</title>
              <link>https://www.isa-afp.org/entries/Abs_Int_ITP2012.shtml</link>
       <guid>https://www.isa-afp.org/entries/Abs_Int_ITP2012.shtml</guid>
       <dc:creator> Tobias Nipkow       </dc:creator>
       <pubDate>23 Nov 2016 00:00:00 +0000</pubDate>
       <description>
This is the Isabelle formalization of the material decribed in the
eponymous &lt;a href=&#34;http://dx.doi.org/10.1007/978-3-642-32347-8_9&#34;&gt;ITP 2012 paper&lt;/a&gt;.
It develops a generic abstract interpreter for a
while-language, including widening and narrowing. The collecting
semantics and the abstract interpreter operate on annotated commands:
the program is represented as a syntax tree with the semantic
information directly embedded, without auxiliary labels. The aim of
the formalization is simplicity, not efficiency or
precision. This is motivated by the inclusion of the material in a
theorem prover based course on semantics. A similar (but more
polished) development is covered in the book
&lt;a href=&#34;http://dx.doi.org/10.1007/978-3-319-10542-0&#34;&gt;Concrete Semantics&lt;/a&gt;.</description>
    </item>
    <item>
       <title>Separata: Isabelle tactics for Separation Algebra</title>
              <link>https://www.isa-afp.org/entries/Separata.shtml</link>
       <guid>https://www.isa-afp.org/entries/Separata.shtml</guid>
       <dc:creator> Zhe Hou, David Sanan, Alwen Tiu, Rajeev Gore, Ranald Clouston       </dc:creator>
       <pubDate>16 Nov 2016 00:00:00 +0000</pubDate>
       <description>
We bring the labelled sequent calculus $LS_{PASL}$ for propositional
abstract separation logic to Isabelle. The tactics given here are
directly applied on an extension of the Separation Algebra in the AFP.
In addition to the cancellative separation algebra, we further
consider some useful properties in the heap model of separation logic,
such as indivisible unit, disjointness, and cross-split. The tactics
are essentially a proof search procedure for the calculus $LS_{PASL}$.
We wrap the tactics in an Isabelle method called separata, and give a
few examples of separation logic formulae which are provable by
separata.</description>
    </item>
    <item>
       <title>Formalization of Nested Multisets, Hereditary Multisets, and Syntactic Ordinals</title>
              <link>https://www.isa-afp.org/entries/Nested_Multisets_Ordinals.shtml</link>
       <guid>https://www.isa-afp.org/entries/Nested_Multisets_Ordinals.shtml</guid>
       <dc:creator> Jasmin Christian Blanchette, Mathias Fleury, Dmitriy Traytel       </dc:creator>
       <pubDate>12 Nov 2016 00:00:00 +0000</pubDate>
       <description>This Isabelle/HOL formalization introduces a nested multiset datatype and defines Dershowitz and Manna&#39;s nested multiset order. The order is proved well founded and linear. By removing one constructor, we transform the nested multisets into hereditary multisets. These are isomorphic to the syntactic ordinals—the ordinals can be recursively expressed in Cantor normal form. Addition, subtraction, multiplication, and linear orders are provided on this type.</description>
    </item>
    <item>
       <title>Formalization of Knuth–Bendix Orders for Lambda-Free Higher-Order Terms</title>
              <link>https://www.isa-afp.org/entries/Lambda_Free_KBOs.shtml</link>
       <guid>https://www.isa-afp.org/entries/Lambda_Free_KBOs.shtml</guid>
       <dc:creator> Heiko Becker, Jasmin Christian Blanchette, Uwe Waldmann, Daniel Wand       </dc:creator>
       <pubDate>12 Nov 2016 00:00:00 +0000</pubDate>
       <description>This Isabelle/HOL formalization defines Knuth–Bendix orders for higher-order terms without lambda-abstraction and proves many useful properties about them. The main order fully coincides with the standard transfinite KBO with subterm coefficients on first-order terms. It appears promising as the basis of a higher-order superposition calculus.</description>
    </item>
    <item>
       <title>Expressiveness of Deep Learning</title>
              <link>https://www.isa-afp.org/entries/Deep_Learning.shtml</link>
       <guid>https://www.isa-afp.org/entries/Deep_Learning.shtml</guid>
       <dc:creator> Alexander Bentkamp       </dc:creator>
       <pubDate>10 Nov 2016 00:00:00 +0000</pubDate>
       <description>
Deep learning has had a profound impact on computer science in recent years, with applications to search engines, image recognition and language processing, bioinformatics, and more. Recently, Cohen et al. provided theoretical evidence for the superiority of deep learning over shallow learning. This formalization of their work simplifies and generalizes the original proof, while working around the limitations of the Isabelle type system. To support the formalization, I developed reusable libraries of formalized mathematics, including results about the matrix rank, the Lebesgue measure, and multivariate polynomials, as well as a library for tensor analysis.</description>
    </item>
    <item>
       <title>Modal Logics for Nominal Transition Systems</title>
              <link>https://www.isa-afp.org/entries/Modal_Logics_for_NTS.shtml</link>
       <guid>https://www.isa-afp.org/entries/Modal_Logics_for_NTS.shtml</guid>
       <dc:creator> Tjark Weber, Lars-Henrik Eriksson, Joachim Parrow, Johannes Borgström, Ramunas Gutkovas       </dc:creator>
       <pubDate>25 Oct 2016 00:00:00 +0000</pubDate>
       <description>
We formalize a uniform semantic substrate for a wide variety of
process calculi where states and action labels can be from arbitrary
nominal sets. A Hennessy-Milner logic for these systems is defined,
and proved adequate for bisimulation equivalence. A main novelty is
the construction of an infinitary nominal data type to model formulas
with (finitely supported) infinite conjunctions and actions that may
contain binding names. The logic is generalized to treat different
bisimulation variants such as early, late and open in a systematic
way.</description>
    </item>
    <item>
       <title>Stable Matching</title>
              <link>https://www.isa-afp.org/entries/Stable_Matching.shtml</link>
       <guid>https://www.isa-afp.org/entries/Stable_Matching.shtml</guid>
       <dc:creator> Peter Gammie       </dc:creator>
       <pubDate>24 Oct 2016 00:00:00 +0000</pubDate>
       <description>
We mechanize proofs of several results from the matching with
contracts literature, which generalize those of the classical
two-sided matching scenarios that go by the name of stable marriage.
Our focus is on game theoretic issues. Along the way we develop
executable algorithms for computing optimal stable matches.</description>
    </item>
  </channel>
</rss>
