<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>06 Sep 2017 00:00:00 +0000</pubDate>
    <item>
       <title>Anselm's God in Isabelle/HOL</title>
              <link>https://www.isa-afp.org/entries/AnselmGod.html</link>
       <guid>https://www.isa-afp.org/entries/AnselmGod.html</guid>
       <dc:creator> Ben Blumson       </dc:creator>
       <pubDate>06 Sep 2017 00:00:00 +0000</pubDate>
       <description>
Paul Oppenheimer and Edward Zalta&#39;s formalisation of
Anselm&#39;s ontological argument for the existence of God is
automated by embedding a free logic for definite descriptions within
Isabelle/HOL.</description>
    </item>
    <item>
       <title>Microeconomics and the First Welfare Theorem</title>
              <link>https://www.isa-afp.org/entries/First_Welfare_Theorem.html</link>
       <guid>https://www.isa-afp.org/entries/First_Welfare_Theorem.html</guid>
       <dc:creator> Julian Parsert, Cezary Kaliszyk       </dc:creator>
       <pubDate>01 Sep 2017 00:00:00 +0000</pubDate>
       <description>
Economic activity has always been a fundamental part of society. Due
to modern day politics, economic theory has gained even more influence
on our lives. Thus we want models and theories to be as precise as
possible. This can be achieved using certification with the help of
formal proof technology. Hence we will use Isabelle/HOL to construct
two economic models, that of the the pure exchange economy and a
version of the Arrow-Debreu Model. We will prove that the
&lt;i&gt;First Theorem of Welfare Economics&lt;/i&gt; holds within
both. The theorem is the mathematical formulation of Adam Smith&#39;s
famous &lt;i&gt;invisible hand&lt;/i&gt; and states that a group of
self-interested and rational actors will eventually achieve an
efficient allocation of goods and services.</description>
    </item>
    <item>
       <title>Root-Balanced Tree</title>
              <link>https://www.isa-afp.org/entries/Root_Balanced_Tree.html</link>
       <guid>https://www.isa-afp.org/entries/Root_Balanced_Tree.html</guid>
       <dc:creator> Tobias Nipkow       </dc:creator>
       <pubDate>20 Aug 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;
Andersson introduced &lt;em&gt;general balanced trees&lt;/em&gt;,
search trees based on the design principle of partial rebuilding:
perform update operations naively until the tree becomes too
unbalanced, at which point a whole subtree is rebalanced.  This article
defines and analyzes a functional version of general balanced trees,
which we call &lt;em&gt;root-balanced trees&lt;/em&gt;. Using a lightweight model
of execution time, amortized logarithmic complexity is verified in
the theorem prover Isabelle.
&lt;/p&gt;
&lt;p&gt;
This is the Isabelle formalization of the material decribed in the APLAS 2017 article
&lt;a href=&#34;http://www.in.tum.de/~nipkow/pubs/aplas17.html&#34;&gt;Verified Root-Balanced Trees&lt;/a&gt;
by the same author, which also presents experimental results that show
competitiveness of root-balanced with AVL and red-black trees.
&lt;/p&gt;</description>
    </item>
    <item>
       <title>Orbit-Stabiliser Theorem with Application to Rotational Symmetries</title>
              <link>https://www.isa-afp.org/entries/Orbit_Stabiliser.html</link>
       <guid>https://www.isa-afp.org/entries/Orbit_Stabiliser.html</guid>
       <dc:creator> Jonas Rädle       </dc:creator>
       <pubDate>20 Aug 2017 00:00:00 +0000</pubDate>
       <description>
The Orbit-Stabiliser theorem is a basic result in the algebra of
groups that factors the order of a group into the sizes of its orbits
and stabilisers.  We formalize the notion of a group action and the
related concepts of orbits and stabilisers. This allows us to prove
the orbit-stabiliser theorem.  In the second part of this work, we
formalize the tetrahedral group and use the orbit-stabiliser theorem
to prove that there are twelve (orientation-preserving) rotations of
the tetrahedron.</description>
    </item>
    <item>
       <title>The LambdaMu-calculus</title>
              <link>https://www.isa-afp.org/entries/LambdaMu.html</link>
       <guid>https://www.isa-afp.org/entries/LambdaMu.html</guid>
       <dc:creator> Cristina Matache, Victor B. F. Gomes, Dominic P. Mulligan       </dc:creator>
       <pubDate>16 Aug 2017 00:00:00 +0000</pubDate>
       <description>
The propositions-as-types correspondence is ordinarily presented as
linking the metatheory of typed λ-calculi and the proof theory of
intuitionistic logic. Griffin observed that this correspondence could
be extended to classical logic through the use of control operators.
This observation set off a flurry of further research, leading to the
development of Parigots λμ-calculus. In this work, we formalise λμ-
calculus in Isabelle/HOL and prove several metatheoretical properties
such as type preservation and progress.</description>
    </item>
    <item>
       <title>Stewart's Theorem and Apollonius' Theorem</title>
              <link>https://www.isa-afp.org/entries/Stewart_Apollonius.html</link>
       <guid>https://www.isa-afp.org/entries/Stewart_Apollonius.html</guid>
       <dc:creator> Lukas Bulwahn       </dc:creator>
       <pubDate>31 Jul 2017 00:00:00 +0000</pubDate>
       <description>
This entry formalizes the two geometric theorems, Stewart&#39;s and
Apollonius&#39; theorem. Stewart&#39;s Theorem relates the length of
a triangle&#39;s cevian to the lengths of the triangle&#39;s two
sides. Apollonius&#39; Theorem is a specialisation of Stewart&#39;s
theorem, restricting the cevian to be the median. The proof applies
the law of cosines, some basic geometric facts about triangles and
then simply transforms the terms algebraically to yield the
conjectured relation. The formalization in Isabelle can closely follow
the informal proofs described in the Wikipedia articles of those two
theorems.</description>
    </item>
    <item>
       <title>Dynamic Architectures</title>
              <link>https://www.isa-afp.org/entries/DynamicArchitectures.html</link>
       <guid>https://www.isa-afp.org/entries/DynamicArchitectures.html</guid>
       <dc:creator> Diego Marmsoler       </dc:creator>
       <pubDate>28 Jul 2017 00:00:00 +0000</pubDate>
       <description>
The architecture of a system describes the system&#39;s overall
organization into components and connections between those components.
With the emergence of mobile computing, dynamic architectures have
become increasingly important. In such architectures, components may
appear or disappear, and connections may change over time. In the
following we mechanize a theory of dynamic architectures and verify
the soundness of a corresponding calculus. Therefore, we first
formalize the notion of configuration traces as a model for dynamic
architectures. Then, the behavior of single components is formalized
in terms of behavior traces and an operator is introduced and studied
to extract the behavior of a single component out of a given
configuration trace. Then, behavior trace assertions are introduced as
a temporal specification technique to specify behavior of components.
Reasoning about component behavior in a dynamic context is formalized
in terms of a calculus for dynamic architectures. Finally, the
soundness of the calculus is verified by introducing an alternative
interpretation for behavior trace assertions over configuration traces
and proving the rules of the calculus. Since projection may lead to
finite as well as infinite behavior traces, they are formalized in
terms of coinductive lists. Thus, our theory is based on
Lochbihler&#39;s formalization of coinductive lists. The theory may
be applied to verify properties for dynamic architectures.</description>
    </item>
    <item>
       <title>Declarative Semantics for Functional Languages</title>
              <link>https://www.isa-afp.org/entries/Decl_Sem_Fun_PL.html</link>
       <guid>https://www.isa-afp.org/entries/Decl_Sem_Fun_PL.html</guid>
       <dc:creator> Jeremy Siek       </dc:creator>
       <pubDate>21 Jul 2017 00:00:00 +0000</pubDate>
       <description>
We present a semantics for an applied call-by-value lambda-calculus
that is compositional, extensional, and elementary. We present four
different views of the semantics: 1) as a relational (big-step)
semantics that is not operational but instead declarative, 2) as a
denotational semantics that does not use domain theory, 3) as a
non-deterministic interpreter, and 4) as a variant of the intersection
type systems of the Torino group.  We prove that the semantics is
correct by showing that it is sound and complete with respect to
operational semantics on programs and that is sound with respect to
contextual equivalence. We have not yet investigated whether it is
fully abstract. We demonstrate that this approach to semantics is
useful with three case studies. First, we use the semantics to prove
correctness of a compiler optimization that inlines function
application. Second, we adapt the semantics to the polymorphic
lambda-calculus extended with general recursion and prove semantic
type soundness.  Third, we adapt the semantics to the call-by-value
lambda-calculus with mutable references.
&lt;br&gt;
The paper that accompanies these Isabelle theories is &lt;a href=&#34;https://arxiv.org/abs/1707.03762&#34;&gt;available on arXiv&lt;/a&gt;.</description>
    </item>
    <item>
       <title>HOLCF-Prelude</title>
              <link>https://www.isa-afp.org/entries/HOLCF-Prelude.html</link>
       <guid>https://www.isa-afp.org/entries/HOLCF-Prelude.html</guid>
       <dc:creator> Joachim Breitner, Brian Huffman, Neil Mitchell, Christian Sternagel       </dc:creator>
       <pubDate>15 Jul 2017 00:00:00 +0000</pubDate>
       <description>
The Isabelle/HOLCF-Prelude is a formalization of a large part of
Haskell&#39;s standard prelude in Isabelle/HOLCF. We use it to prove
the correctness of the Eratosthenes&#39; Sieve, in its
self-referential implementation commonly used to showcase
Haskell&#39;s laziness; prove correctness of GHC&#39;s
&#34;fold/build&#34; rule and related rewrite rules; and certify a
number of hints suggested by HLint.</description>
    </item>
    <item>
       <title>Minkowski's Theorem</title>
              <link>https://www.isa-afp.org/entries/Minkowskis_Theorem.html</link>
       <guid>https://www.isa-afp.org/entries/Minkowskis_Theorem.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>13 Jul 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;Minkowski&#39;s theorem relates a subset of
&amp;#8477;&lt;sup&gt;n&lt;/sup&gt;, the Lebesgue measure, and the
integer lattice &amp;#8484;&lt;sup&gt;n&lt;/sup&gt;: It states that
any convex subset of &amp;#8477;&lt;sup&gt;n&lt;/sup&gt; with volume
greater than 2&lt;sup&gt;n&lt;/sup&gt; contains at least one lattice
point from &amp;#8484;&lt;sup&gt;n&lt;/sup&gt;\{0}, i.&amp;thinsp;e. a
non-zero point with integer coefficients.&lt;/p&gt;  &lt;p&gt;A
related theorem which directly implies this is Blichfeldt&#39;s
theorem, which states that any subset of
&amp;#8477;&lt;sup&gt;n&lt;/sup&gt; with a volume greater than 1
contains two different points whose difference vector has integer
components.&lt;/p&gt;  &lt;p&gt;The entry contains a proof of both
theorems.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Verified Metatheory and Type Inference for a Name-Carrying Simply-Typed Lambda Calculus</title>
              <link>https://www.isa-afp.org/entries/Name_Carrying_Type_Inference.html</link>
       <guid>https://www.isa-afp.org/entries/Name_Carrying_Type_Inference.html</guid>
       <dc:creator> Michael Rawson       </dc:creator>
       <pubDate>09 Jul 2017 00:00:00 +0000</pubDate>
       <description>
I formalise a Church-style simply-typed
\(\lambda\)-calculus, extended with pairs, a unit value, and
projection functions, and show some metatheory of the calculus, such
as the subject reduction property. Particular attention is paid to the
treatment of names in the calculus. A nominal style of binding is
used, but I use a manual approach over Nominal Isabelle in order to
extract an executable type inference algorithm. More information can
be found in my &lt;a
href=&#34;http://www.openthesis.org/documents/Verified-Metatheory-Type-Inference-Simply-603182.html&#34;&gt;undergraduate
dissertation&lt;/a&gt;.</description>
    </item>
    <item>
       <title>A framework for establishing Strong Eventual Consistency for Conflict-free Replicated Datatypes</title>
              <link>https://www.isa-afp.org/entries/CRDT.html</link>
       <guid>https://www.isa-afp.org/entries/CRDT.html</guid>
       <dc:creator> Victor B. F. Gomes, Martin Kleppmann, Dominic P. Mulligan, Alastair R. Beresford       </dc:creator>
       <pubDate>07 Jul 2017 00:00:00 +0000</pubDate>
       <description>
In this work, we focus on the correctness of Conflict-free Replicated
Data Types (CRDTs), a class of algorithm that provides strong eventual
consistency guarantees for replicated data. We develop a modular and
reusable framework for verifying the correctness of CRDT algorithms.
We avoid correctness issues that have dogged previous mechanised
proofs in this area by including a network model in our formalisation,
and proving that our theorems hold in all possible network behaviours.
Our axiomatic network model is a standard abstraction that accurately
reflects the behaviour of real-world computer networks. Moreover, we
identify an abstract convergence theorem, a property of order
relations, which provides a formal definition of strong eventual
consistency. We then obtain the first machine-checked correctness
theorems for three concrete CRDTs: the Replicated Growable Array, the
Observed-Remove Set, and an Increment-Decrement Counter.</description>
    </item>
    <item>
       <title>Propositional Proof Systems</title>
              <link>https://www.isa-afp.org/entries/Propositional_Proof_Systems.html</link>
       <guid>https://www.isa-afp.org/entries/Propositional_Proof_Systems.html</guid>
       <dc:creator> Julius Michaelis, Tobias Nipkow       </dc:creator>
       <pubDate>21 Jun 2017 00:00:00 +0000</pubDate>
       <description>
We formalize a range of proof systems for classical propositional
logic (sequent calculus, natural deduction, Hilbert systems,
resolution) and prove the most important meta-theoretic results about
semantics and proofs: compactness, soundness, completeness,
translations between proof systems, cut-elimination, interpolation and
model existence.</description>
    </item>
    <item>
       <title>Partial Semigroups and Convolution Algebras</title>
              <link>https://www.isa-afp.org/entries/PSemigroupsConvolution.html</link>
       <guid>https://www.isa-afp.org/entries/PSemigroupsConvolution.html</guid>
       <dc:creator> Brijesh Dongol, Victor B. F. Gomes, Ian J. Hayes, Georg Struth       </dc:creator>
       <pubDate>13 Jun 2017 00:00:00 +0000</pubDate>
       <description>
Partial Semigroups are relevant to the foundations of quantum
mechanics and combinatorics as well as to interval and separation
logics. Convolution algebras can be understood either as algebras of
generalised binary modalities over ternary Kripke frames, in
particular over partial semigroups, or as algebras of quantale-valued
functions which are equipped with a convolution-style operation of
multiplication that is parametrised by a ternary relation. Convolution
algebras provide algebraic semantics for various substructural logics,
including categorial, relevance and linear logics, for separation
logic and for interval logics; they cover quantitative and qualitative
applications. These mathematical components for partial semigroups and
convolution algebras provide uniform foundations from which models of
computation based on relations, program traces or pomsets, and
verification components for separation or interval temporal logics can
be built with little effort.</description>
    </item>
    <item>
       <title>Buffon's Needle Problem</title>
              <link>https://www.isa-afp.org/entries/Buffons_Needle.html</link>
       <guid>https://www.isa-afp.org/entries/Buffons_Needle.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>06 Jun 2017 00:00:00 +0000</pubDate>
       <description>
In the 18th century, Georges-Louis Leclerc, Comte de Buffon posed and
later solved the following problem, which is often called the first
problem ever solved in geometric probability: Given a floor divided
into vertical strips of the same width, what is the probability that a
needle thrown onto the floor randomly will cross two strips?  This
entry formally defines the problem in the case where the needle&#39;s
position is chosen uniformly at random in a single strip around the
origin (which is equivalent to larger arrangements due to symmetry).
It then provides proofs of the simple solution in the case where the
needle&#39;s length is no greater than the width of the strips and
the more complicated solution in the opposite case.</description>
    </item>
    <item>
       <title>Formalizing Push-Relabel Algorithms</title>
              <link>https://www.isa-afp.org/entries/Prpu_Maxflow.html</link>
       <guid>https://www.isa-afp.org/entries/Prpu_Maxflow.html</guid>
       <dc:creator> Peter Lammich, S. Reza Sefidgar       </dc:creator>
       <pubDate>01 Jun 2017 00:00:00 +0000</pubDate>
       <description>
We present a formalization of push-relabel algorithms for computing
the maximum flow in a network. We start with Goldberg&#39;s et
al.~generic push-relabel algorithm, for which we show correctness and
the time complexity bound of O(V^2E). We then derive the
relabel-to-front and FIFO implementation. Using stepwise refinement
techniques, we derive an efficient verified implementation.  Our
formal proof of the abstract algorithms closely follows a standard
textbook proof. It is accessible even without being an expert in
Isabelle/HOL, the interactive theorem prover used for the
formalization.</description>
    </item>
    <item>
       <title>Flow Networks and the Min-Cut-Max-Flow Theorem</title>
              <link>https://www.isa-afp.org/entries/Flow_Networks.html</link>
       <guid>https://www.isa-afp.org/entries/Flow_Networks.html</guid>
       <dc:creator> Peter Lammich, S. Reza Sefidgar       </dc:creator>
       <pubDate>01 Jun 2017 00:00:00 +0000</pubDate>
       <description>
We present a formalization of flow networks and the Min-Cut-Max-Flow
theorem. Our formal proof closely follows a standard textbook proof,
and is accessible even without being an expert in Isabelle/HOL, the
interactive theorem prover used for the formalization.</description>
    </item>
    <item>
       <title>Optics</title>
              <link>https://www.isa-afp.org/entries/Optics.html</link>
       <guid>https://www.isa-afp.org/entries/Optics.html</guid>
       <dc:creator> Simon Foster, Frank Zeyda       </dc:creator>
       <pubDate>25 May 2017 00:00:00 +0000</pubDate>
       <description>
Lenses provide an abstract interface for manipulating data types
through spatially-separated views. They are defined abstractly in
terms of two functions, &lt;em&gt;get&lt;/em&gt;, the return a value
from the source type, and &lt;em&gt;put&lt;/em&gt; that updates the
value. We mechanise the underlying theory of lenses, in terms of an
algebraic hierarchy of lenses, including well-behaved and very
well-behaved lenses, each lens class being characterised by a set of
lens laws. We also mechanise a lens algebra in Isabelle that enables
their composition and comparison, so as to allow construction of
complex lenses. This is accompanied by a large library of algebraic
laws. Moreover we also show how the lens classes can be applied by
instantiating them with a number of Isabelle data types.</description>
    </item>
    <item>
       <title>Developing Security Protocols by Refinement</title>
              <link>https://www.isa-afp.org/entries/Security_Protocol_Refinement.html</link>
       <guid>https://www.isa-afp.org/entries/Security_Protocol_Refinement.html</guid>
       <dc:creator> Christoph Sprenger, Ivano Somaini       </dc:creator>
       <pubDate>24 May 2017 00:00:00 +0000</pubDate>
       <description>
We propose a development method for security protocols based on
stepwise refinement. Our refinement strategy transforms abstract
security goals into protocols that are secure when operating over an
insecure channel controlled by a Dolev-Yao-style intruder. As
intermediate levels of abstraction, we employ messageless guard
protocols and channel protocols communicating over channels with
security properties. These abstractions provide insights on why
protocols are secure and foster the development of families of
protocols sharing common structure and properties. We have implemented
our method in Isabelle/HOL and used it to develop different entity
authentication and key establishment protocols, including realistic
features such as key confirmation, replay caches, and encrypted
tickets. Our development highlights that guard protocols and channel
protocols provide fundamental abstractions for bridging the gap
between security properties and standard protocol descriptions based
on cryptographic messages. It also shows that our refinement approach
scales to protocols of nontrivial size and complexity.</description>
    </item>
    <item>
       <title>The Floyd-Warshall Algorithm for Shortest Paths</title>
              <link>https://www.isa-afp.org/entries/Floyd_Warshall.html</link>
       <guid>https://www.isa-afp.org/entries/Floyd_Warshall.html</guid>
       <dc:creator> Simon Wimmer, Peter Lammich       </dc:creator>
       <pubDate>08 May 2017 00:00:00 +0000</pubDate>
       <description>
The Floyd-Warshall algorithm [Flo62, Roy59, War62] is a classic
dynamic programming algorithm to compute the length of all shortest
paths between any two vertices in a graph (i.e. to solve the all-pairs
shortest path problem, or APSP for short). Given a representation of
the graph as a matrix of weights M, it computes another matrix M&#39;
which represents a graph with the same path lengths and contains the
length of the shortest path between any two vertices i and j. This is
only possible if the graph does not contain any negative cycles.
However, in this case the Floyd-Warshall algorithm will detect the
situation by calculating a negative diagonal entry. This entry
includes a formalization of the algorithm and of these key properties.
The algorithm is refined to an efficient imperative version using the
Imperative Refinement Framework.</description>
    </item>
    <item>
       <title>Probabilistic while loop</title>
              <link>https://www.isa-afp.org/entries/Probabilistic_While.html</link>
       <guid>https://www.isa-afp.org/entries/Probabilistic_While.html</guid>
       <dc:creator> Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
This AFP entry defines a probabilistic while operator based on
sub-probability mass functions and formalises zero-one laws and variant
rules for probabilistic loop termination. As applications, we
implement probabilistic algorithms for the Bernoulli, geometric and
arbitrary uniform distributions that only use fair coin flips, and
prove them correct and terminating with probability 1.</description>
    </item>
    <item>
       <title>Effect polymorphism in higher-order logic</title>
              <link>https://www.isa-afp.org/entries/Monomorphic_Monad.html</link>
       <guid>https://www.isa-afp.org/entries/Monomorphic_Monad.html</guid>
       <dc:creator> Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
The notion of a monad cannot be expressed within higher-order logic
(HOL) due to type system restrictions. We show that if a monad is used
with values of only one type, this notion can be formalised in HOL.
Based on this idea, we develop a library of effect specifications and
implementations of monads and monad transformers. Hence, we can
abstract over the concrete monad in HOL definitions and thus use the
same definition for different (combinations of) effects. We illustrate
the usefulness of effect polymorphism with a monadic interpreter for a
simple language.</description>
    </item>
    <item>
       <title>Monad normalisation</title>
              <link>https://www.isa-afp.org/entries/Monad_Normalisation.html</link>
       <guid>https://www.isa-afp.org/entries/Monad_Normalisation.html</guid>
       <dc:creator> Joshua Schneider, Manuel Eberl, Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
The usual monad laws can directly be used as rewrite rules for Isabelle’s
simplifier to normalise monadic HOL terms and decide equivalences.
In a commutative monad, however, the commutativity law is a
higher-order permutative rewrite rule that makes the simplifier loop.
This AFP entry implements a simproc that normalises monadic
expressions in commutative monads using ordered rewriting. The
simproc can also permute computations across control operators like if
and case.</description>
    </item>
    <item>
       <title>Game-based cryptography in HOL</title>
              <link>https://www.isa-afp.org/entries/Game_Based_Crypto.html</link>
       <guid>https://www.isa-afp.org/entries/Game_Based_Crypto.html</guid>
       <dc:creator> Andreas Lochbihler, S. Reza Sefidgar, Bhargav Bhatt       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;In this AFP entry, we show how to specify game-based cryptographic
security notions and formally prove secure several cryptographic
constructions from the literature using the CryptHOL framework. Among
others, we formalise the notions of a random oracle, a pseudo-random
function, an unpredictable function, and of encryption schemes that are
indistinguishable under chosen plaintext and/or ciphertext attacks. We
prove the random-permutation/random-function switching lemma, security
of the Elgamal and hashed Elgamal public-key encryption scheme and
correctness and security of several constructions with pseudo-random
functions.
&lt;/p&gt;&lt;p&gt;Our proofs follow the game-hopping style advocated by
Shoup and Bellare and Rogaway, from which most of the examples have
been taken. We generalise some of their results such that they can be
reused in other proofs. Thanks to CryptHOL&#39;s integration with
Isabelle&#39;s parametricity infrastructure, many simple hops are easily
justified using the theory of representation independence.&lt;/p&gt;</description>
    </item>
    <item>
       <title>CryptHOL</title>
              <link>https://www.isa-afp.org/entries/CryptHOL.html</link>
       <guid>https://www.isa-afp.org/entries/CryptHOL.html</guid>
       <dc:creator> Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;CryptHOL provides a framework for formalising cryptographic arguments
in Isabelle/HOL. It shallowly embeds a probabilistic functional
programming language in higher order logic. The language features
monadic sequencing, recursion, random sampling, failures and failure
handling, and black-box access to oracles. Oracles are probabilistic
functions which maintain hidden state between different invocations.
All operators are defined in the new semantic domain of
generative probabilistic values, a codatatype. We derive proof rules for
the operators and establish a connection with the theory of relational
parametricity. Thus, the resuting proofs are trustworthy and
comprehensible, and the framework is extensible and widely applicable.
&lt;/p&gt;&lt;p&gt;
The framework is used in the accompanying AFP entry &#34;Game-based
Cryptography in HOL&#34;. There, we show-case our framework by formalizing
different game-based proofs from the literature. This formalisation
continues the work described in the author&#39;s ESOP 2016 paper.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Monoidal Categories</title>
              <link>https://www.isa-afp.org/entries/MonoidalCategory.html</link>
       <guid>https://www.isa-afp.org/entries/MonoidalCategory.html</guid>
       <dc:creator> Eugene W. Stark       </dc:creator>
       <pubDate>04 May 2017 00:00:00 +0000</pubDate>
       <description>
Building on the formalization of basic category theory set out in the
author&#39;s previous AFP article, the present article formalizes
some basic aspects of the theory of monoidal categories. Among the
notions defined here are monoidal category, monoidal functor, and
equivalence of monoidal categories. The main theorems formalized are
MacLane&#39;s coherence theorem and the constructions of the free
monoidal category and free strict monoidal category generated by a
given category.  The coherence theorem is proved syntactically, using
a structurally recursive approach to reduction of terms that might
have some novel aspects. We also give proofs of some results given by
Etingof et al, which may prove useful in a formal setting. In
particular, we show that the left and right unitors need not be taken
as given data in the definition of monoidal category, nor does the
definition of monoidal functor need to take as given a specific
isomorphism expressing the preservation of the unit object. Our
definitions of monoidal category and monoidal functor are stated so as
to take advantage of the economy afforded by these facts.</description>
    </item>
    <item>
       <title>Types, Tableaus and Gödel’s God in Isabelle/HOL</title>
              <link>https://www.isa-afp.org/entries/Types_Tableaus_and_Goedels_God.html</link>
       <guid>https://www.isa-afp.org/entries/Types_Tableaus_and_Goedels_God.html</guid>
       <dc:creator> David Fuenmayor, Christoph Benzmüller       </dc:creator>
       <pubDate>01 May 2017 00:00:00 +0000</pubDate>
       <description>
A computer-formalisation of the essential parts of Fitting&#39;s
textbook &#34;Types, Tableaus and Gödel&#39;s God&#34; in
Isabelle/HOL is presented. In particular, Fitting&#39;s (and
Anderson&#39;s) variant of the ontological argument is verified and
confirmed. This variant avoids the modal collapse, which has been
criticised as an undesirable side-effect of Kurt Gödel&#39;s (and
Dana Scott&#39;s) versions of the ontological argument.
Fitting&#39;s work is employing an intensional higher-order modal
logic, which we shallowly embed here in classical higher-order logic.
We then utilize the embedded logic for the formalisation of
Fitting&#39;s argument. (See also the earlier AFP entry ``Gödel&#39;s God in Isabelle/HOL&#39;&#39;.)</description>
    </item>
    <item>
       <title>Local Lexing</title>
              <link>https://www.isa-afp.org/entries/LocalLexing.html</link>
       <guid>https://www.isa-afp.org/entries/LocalLexing.html</guid>
       <dc:creator> Steven Obua       </dc:creator>
       <pubDate>28 Apr 2017 00:00:00 +0000</pubDate>
       <description>
This formalisation accompanies the paper &lt;a
href=&#34;https://arxiv.org/abs/1702.03277&#34;&gt;Local
Lexing&lt;/a&gt; which introduces a novel parsing concept of the same
name. The paper also gives a high-level algorithm for local lexing as
an extension of Earley&#39;s algorithm. This formalisation proves the
algorithm to be correct with respect to its local lexing semantics. As
a special case, this formalisation thus also contains a proof of the
correctness of Earley&#39;s algorithm. The paper contains a short
outline of how this formalisation is organised.</description>
    </item>
    <item>
       <title>Constructor Functions</title>
              <link>https://www.isa-afp.org/entries/Constructor_Funs.html</link>
       <guid>https://www.isa-afp.org/entries/Constructor_Funs.html</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>19 Apr 2017 00:00:00 +0000</pubDate>
       <description>
Isabelle&#39;s code generator performs various adaptations for target
languages. Among others, constructor applications have to be fully
saturated. That means that for constructor calls occuring as arguments
to higher-order functions, synthetic lambdas have to be inserted. This
entry provides tooling to avoid this construction altogether by
introducing constructor functions.</description>
    </item>
    <item>
       <title>Lazifying case constants</title>
              <link>https://www.isa-afp.org/entries/Lazy_Case.html</link>
       <guid>https://www.isa-afp.org/entries/Lazy_Case.html</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>18 Apr 2017 00:00:00 +0000</pubDate>
       <description>
Isabelle&#39;s code generator performs various adaptations for target
languages. Among others, case statements are printed as match
expressions. Internally, this is a sophisticated procedure, because in
HOL, case statements are represented as nested calls to the case
combinators as generated by the datatype package. Furthermore, the
procedure relies on laziness of match expressions in the target
language, i.e., that branches guarded by patterns that fail to match
are not evaluated. Similarly, &lt;tt&gt;if-then-else&lt;/tt&gt; is
printed to the corresponding construct in the target language. This
entry provides tooling to replace these special cases in the code
generator by ignoring these target language features, instead printing
case expressions and &lt;tt&gt;if-then-else&lt;/tt&gt; as functions.</description>
    </item>
  </channel>
</rss>
