<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>08 May 2017 00:00:00 +0000</pubDate>
    <item>
       <title>The Floyd-Warshall Algorithm for Shortest Paths</title>
              <link>https://www.isa-afp.org/entries/Floyd_Warshall.shtml</link>
       <guid>https://www.isa-afp.org/entries/Floyd_Warshall.shtml</guid>
       <dc:creator> Simon Wimmer, Peter Lammich       </dc:creator>
       <pubDate>08 May 2017 00:00:00 +0000</pubDate>
       <description>
The Floyd-Warshall algorithm [Flo62, Roy59, War62] is a classic
dynamic programming algorithm to compute the length of all shortest
paths between any two vertices in a graph (i.e. to solve the all-pairs
shortest path problem, or APSP for short). Given a representation of
the graph as a matrix of weights M, it computes another matrix M&#39;
which represents a graph with the same path lengths and contains the
length of the shortest path between any two vertices i and j. This is
only possible if the graph does not contain any negative cycles.
However, in this case the Floyd-Warshall algorithm will detect the
situation by calculating a negative diagonal entry. This entry
includes a formalization of the algorithm and of these key properties.
The algorithm is refined to an efficient imperative version using the
Imperative Refinement Framework.</description>
    </item>
    <item>
       <title>Effect polymorphism in higher-order logic</title>
              <link>https://www.isa-afp.org/entries/Monomorphic_Monad.shtml</link>
       <guid>https://www.isa-afp.org/entries/Monomorphic_Monad.shtml</guid>
       <dc:creator> Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
The notion of a monad cannot be expressed within higher-order logic
(HOL) due to type system restrictions. We show that if a monad is used
with values of only one type, this notion can be formalised in HOL.
Based on this idea, we develop a library of effect specifications and
implementations of monads and monad transformers. Hence, we can
abstract over the concrete monad in HOL definitions and thus use the
same definition for different (combinations of) effects. We illustrate
the usefulness of effect polymorphism with a monadic interpreter for a
simple language.</description>
    </item>
    <item>
       <title>Monoidal Categories</title>
              <link>https://www.isa-afp.org/entries/MonoidalCategory.shtml</link>
       <guid>https://www.isa-afp.org/entries/MonoidalCategory.shtml</guid>
       <dc:creator> Eugene W. Stark       </dc:creator>
       <pubDate>04 May 2017 00:00:00 +0000</pubDate>
       <description>
Building on the formalization of basic category theory set out in the
author&#39;s previous AFP article, the present article formalizes
some basic aspects of the theory of monoidal categories. Among the
notions defined here are monoidal category, monoidal functor, and
equivalence of monoidal categories. The main theorems formalized are
MacLane&#39;s coherence theorem and the constructions of the free
monoidal category and free strict monoidal category generated by a
given category.  The coherence theorem is proved syntactically, using
a structurally recursive approach to reduction of terms that might
have some novel aspects. We also give proofs of some results given by
Etingof et al, which may prove useful in a formal setting. In
particular, we show that the left and right unitors need not be taken
as given data in the definition of monoidal category, nor does the
definition of monoidal functor need to take as given a specific
isomorphism expressing the preservation of the unit object. Our
definitions of monoidal category and monoidal functor are stated so as
to take advantage of the economy afforded by these facts.</description>
    </item>
    <item>
       <title>Types, Tableaus and Gödel’s God in Isabelle/HOL</title>
              <link>https://www.isa-afp.org/entries/Types_Tableaus_and_Goedels_God.shtml</link>
       <guid>https://www.isa-afp.org/entries/Types_Tableaus_and_Goedels_God.shtml</guid>
       <dc:creator> David Fuenmayor, Christoph Benzmüller       </dc:creator>
       <pubDate>01 May 2017 00:00:00 +0000</pubDate>
       <description>
A computer-formalisation of the essential parts of Fitting&#39;s
textbook &#34;Types, Tableaus and Gödel&#39;s God&#34; in
Isabelle/HOL is presented. In particular, Fitting&#39;s (and
Anderson&#39;s) variant of the ontological argument is verified and
confirmed. This variant avoids the modal collapse, which has been
criticised as an undesirable side-effect of Kurt Gödel&#39;s (and
Dana Scott&#39;s) versions of the ontological argument.
Fitting&#39;s work is employing an intensional higher-order modal
logic, which we shallowly embed here in classical higher-order logic.
We then utilize the embedded logic for the formalisation of
Fitting&#39;s argument. (See also the earlier AFP entry ``Gödel&#39;s God in Isabelle/HOL&#39;&#39;.)</description>
    </item>
    <item>
       <title>Local Lexing</title>
              <link>https://www.isa-afp.org/entries/LocalLexing.shtml</link>
       <guid>https://www.isa-afp.org/entries/LocalLexing.shtml</guid>
       <dc:creator> Steven Obua       </dc:creator>
       <pubDate>28 Apr 2017 00:00:00 +0000</pubDate>
       <description>
This formalisation accompanies the paper &lt;a
href=&#34;https://arxiv.org/abs/1702.03277&#34;&gt;Local
Lexing&lt;/a&gt; which introduces a novel parsing concept of the same
name. The paper also gives a high-level algorithm for local lexing as
an extension of Earley&#39;s algorithm. This formalisation proves the
algorithm to be correct with respect to its local lexing semantics. As
a special case, this formalisation thus also contains a proof of the
correctness of Earley&#39;s algorithm. The paper contains a short
outline of how this formalisation is organised.</description>
    </item>
    <item>
       <title>Constructor Functions</title>
              <link>https://www.isa-afp.org/entries/Constructor_Funs.shtml</link>
       <guid>https://www.isa-afp.org/entries/Constructor_Funs.shtml</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>19 Apr 2017 00:00:00 +0000</pubDate>
       <description>
Isabelle&#39;s code generator performs various adaptations for target
languages. Among others, constructor applications have to be fully
saturated. That means that for constructor calls occuring as arguments
to higher-order functions, synthetic lambdas have to be inserted. This
entry provides tooling to avoid this construction altogether by
introducing constructor functions.</description>
    </item>
    <item>
       <title>Lazifying case constants</title>
              <link>https://www.isa-afp.org/entries/Lazy_Case.shtml</link>
       <guid>https://www.isa-afp.org/entries/Lazy_Case.shtml</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>18 Apr 2017 00:00:00 +0000</pubDate>
       <description>
Isabelle&#39;s code generator performs various adaptations for target
languages. Among others, case statements are printed as match
expressions. Internally, this is a sophisticated procedure, because in
HOL, case statements are represented as nested calls to the case
combinators as generated by the datatype package. Furthermore, the
procedure relies on laziness of match expressions in the target
language, i.e., that branches guarded by patterns that fail to match
are not evaluated. Similarly, &lt;tt&gt;if-then-else&lt;/tt&gt; is
printed to the corresponding construct in the target language. This
entry provides tooling to replace these special cases in the code
generator by ignoring these target language features, instead printing
case expressions and &lt;tt&gt;if-then-else&lt;/tt&gt; as functions.</description>
    </item>
    <item>
       <title>Subresultants</title>
              <link>https://www.isa-afp.org/entries/Subresultants.shtml</link>
       <guid>https://www.isa-afp.org/entries/Subresultants.shtml</guid>
       <dc:creator> Sebastiaan Joosten, René Thiemann, Akihisa Yamada       </dc:creator>
       <pubDate>06 Apr 2017 00:00:00 +0000</pubDate>
       <description>
We formalize the theory of subresultants and the subresultant
polynomial remainder sequence as described by Brown and Traub. As a
result, we obtain efficient certified algorithms for computing the
resultant and the greatest common divisor of polynomials.</description>
    </item>
    <item>
       <title>Expected Shape of Random Binary Search Trees</title>
              <link>https://www.isa-afp.org/entries/Random_BSTs.shtml</link>
       <guid>https://www.isa-afp.org/entries/Random_BSTs.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>04 Apr 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry contains proofs for the textbook results about the
distributions of the height and internal path length of random binary
search trees (BSTs), i.&amp;thinsp;e. BSTs that are formed by taking
an empty BST and inserting elements from a fixed set in random
order.&lt;/p&gt;  &lt;p&gt;In particular, we prove a logarithmic upper
bound on the expected height and the &lt;em&gt;Θ(n log n)&lt;/em&gt;
closed-form solution for the expected internal path length in terms of
the harmonic numbers. We also show how the internal path length
relates to the average-case cost of a lookup in a BST.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The number of comparisons in QuickSort</title>
              <link>https://www.isa-afp.org/entries/Quick_Sort_Cost.shtml</link>
       <guid>https://www.isa-afp.org/entries/Quick_Sort_Cost.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>15 Mar 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;We give a formal proof of the well-known results about the
number of comparisons performed by two variants of QuickSort: first,
the expected number of comparisons of randomised QuickSort
(i.&amp;thinsp;e.&amp;nbsp;QuickSort with random pivot choice) is
&lt;em&gt;2&amp;thinsp;(n+1)&amp;thinsp;H&lt;sub&gt;n&lt;/sub&gt; -
4&amp;thinsp;n&lt;/em&gt;, which is asymptotically equivalent to
&lt;em&gt;2&amp;thinsp;n ln n&lt;/em&gt;; second, the number of
comparisons performed by the classic non-randomised QuickSort has the
same distribution in the average case as the randomised one.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Lower bound on comparison-based sorting algorithms</title>
              <link>https://www.isa-afp.org/entries/Comparison_Sort_Lower_Bound.shtml</link>
       <guid>https://www.isa-afp.org/entries/Comparison_Sort_Lower_Bound.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>15 Mar 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article contains a formal proof of the well-known fact
that number of comparisons that a comparison-based sorting algorithm
needs to perform to sort a list of length &lt;em&gt;n&lt;/em&gt; is at
least &lt;em&gt;log&lt;sub&gt;2&lt;/sub&gt;&amp;nbsp;(n!)&lt;/em&gt;
in the worst case, i.&amp;thinsp;e.&amp;nbsp;&lt;em&gt;Ω(n log
n)&lt;/em&gt;.&lt;/p&gt;  &lt;p&gt;For this purpose, a shallow
embedding for comparison-based sorting algorithms is defined: a
sorting algorithm is a recursive datatype containing either a HOL
function or a query of a comparison oracle with a continuation
containing the remaining computation. This makes it possible to force
the algorithm to use only comparisons and to track the number of
comparisons made.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The Euler–MacLaurin Formula</title>
              <link>https://www.isa-afp.org/entries/Euler_MacLaurin.shtml</link>
       <guid>https://www.isa-afp.org/entries/Euler_MacLaurin.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>10 Mar 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The Euler-MacLaurin formula relates the value of a
discrete sum to that of the corresponding integral in terms of the
derivatives at the borders of the summation and a remainder term.
Since the remainder term is often very small as the summation bounds
grow, this can be used to compute asymptotic expansions for
sums.&lt;/p&gt;  &lt;p&gt;This entry contains a proof of this formula
for functions from the reals to an arbitrary Banach space. Two
variants of the formula are given: the standard textbook version and a
variant outlined in &lt;em&gt;Concrete Mathematics&lt;/em&gt; that is
more useful for deriving asymptotic estimates.&lt;/p&gt;  &lt;p&gt;As
example applications, we use that formula to derive the full
asymptotic expansion of the harmonic numbers and the sum of inverse
squares.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The Group Law for Elliptic Curves</title>
              <link>https://www.isa-afp.org/entries/Elliptic_Curves_Group_Law.shtml</link>
       <guid>https://www.isa-afp.org/entries/Elliptic_Curves_Group_Law.shtml</guid>
       <dc:creator> Stefan Berghofer       </dc:creator>
       <pubDate>28 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We prove the group law for elliptic curves in Weierstrass form over
fields of characteristic greater than 2. In addition to affine
coordinates, we also formalize projective coordinates, which allow for
more efficient computations. By specializing the abstract
formalization to prime fields, we can apply the curve operations to
parameters used in standard security protocols.</description>
    </item>
    <item>
       <title>Menger's Theorem</title>
              <link>https://www.isa-afp.org/entries/Menger.shtml</link>
       <guid>https://www.isa-afp.org/entries/Menger.shtml</guid>
       <dc:creator> Christoph Dittmann       </dc:creator>
       <pubDate>26 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We present a formalization of Menger&#39;s Theorem for directed and
undirected graphs in Isabelle/HOL.  This well-known result shows that
if two non-adjacent distinct vertices u, v in a directed graph have no
separator smaller than n, then there exist n internally
vertex-disjoint paths from u to v.  The version for undirected graphs
follows immediately because undirected graphs are a special case of
directed graphs.</description>
    </item>
    <item>
       <title>Differential Dynamic Logic</title>
              <link>https://www.isa-afp.org/entries/Differential_Dynamic_Logic.shtml</link>
       <guid>https://www.isa-afp.org/entries/Differential_Dynamic_Logic.shtml</guid>
       <dc:creator> Brandon Bohrer       </dc:creator>
       <pubDate>13 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We formalize differential dynamic logic, a logic for proving
properties of hybrid systems. The proof calculus in this formalization
is based on the uniform substitution principle. We show it is sound
with respect to our denotational semantics, which provides increased
confidence in the correctness of the KeYmaera X theorem prover based
on this calculus. As an application, we include a proof term checker
embedded in Isabelle/HOL with several example proofs.  Published in:
Brandon Bohrer, Vincent Rahli, Ivana Vukotic, Marcus Völp, André
Platzer: Formally verified differential dynamic logic. CPP 2017.</description>
    </item>
    <item>
       <title>Abstract Soundness</title>
              <link>https://www.isa-afp.org/entries/Abstract_Soundness.shtml</link>
       <guid>https://www.isa-afp.org/entries/Abstract_Soundness.shtml</guid>
       <dc:creator> Jasmin Christian Blanchette, Andrei Popescu, Dmitriy Traytel       </dc:creator>
       <pubDate>10 Feb 2017 00:00:00 +0000</pubDate>
       <description>
A formalized coinductive account of the abstract development of
Brotherston, Gorogiannis, and Petersen [APLAS 2012], in a slightly
more general form since we work with arbitrary infinite proofs, which
may be acyclic. This work is described in detail in an article by the
authors, published in 2017 in the &lt;em&gt;Journal of Automated
Reasoning&lt;/em&gt;. The abstract proof can be instantiated for
various formalisms, including first-order logic with inductive
predicates.</description>
    </item>
    <item>
       <title>Stone Relation Algebras</title>
              <link>https://www.isa-afp.org/entries/Stone_Relation_Algebras.shtml</link>
       <guid>https://www.isa-afp.org/entries/Stone_Relation_Algebras.shtml</guid>
       <dc:creator> Walter Guttmann       </dc:creator>
       <pubDate>07 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We develop Stone relation algebras, which generalise relation algebras
by replacing the underlying Boolean algebra structure with a Stone
algebra. We show that finite matrices over extended real numbers form
an instance. As a consequence, relation-algebraic concepts and methods
can be used for reasoning about weighted graphs. We also develop a
fixpoint calculus and apply it to compare different definitions of
reflexive-transitive closures in semirings.</description>
    </item>
    <item>
       <title>Refining Authenticated Key Agreement with Strong Adversaries</title>
              <link>https://www.isa-afp.org/entries/Key_Agreement_Strong_Adversaries.shtml</link>
       <guid>https://www.isa-afp.org/entries/Key_Agreement_Strong_Adversaries.shtml</guid>
       <dc:creator> Joseph Lallemand, Christoph Sprenger       </dc:creator>
       <pubDate>31 Jan 2017 00:00:00 +0000</pubDate>
       <description>
We develop a family of key agreement protocols that are correct by
construction. Our work substantially extends prior work on developing
security protocols by refinement. First, we strengthen the adversary
by allowing him to compromise different resources of protocol
participants, such as their long-term keys or their session keys. This
enables the systematic development of protocols that ensure strong
properties such as perfect forward secrecy. Second, we broaden the
class of protocols supported to include those with non-atomic keys and
equationally defined cryptographic operators. We use these extensions
to develop key agreement protocols including signed Diffie-Hellman and
the core of IKEv1 and SKEME.</description>
    </item>
    <item>
       <title>Bernoulli Numbers</title>
              <link>https://www.isa-afp.org/entries/Bernoulli.shtml</link>
       <guid>https://www.isa-afp.org/entries/Bernoulli.shtml</guid>
       <dc:creator> Lukas Bulwahn, Manuel Eberl       </dc:creator>
       <pubDate>24 Jan 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;Bernoulli numbers were first discovered in the closed-form
expansion of the sum 1&lt;sup&gt;m&lt;/sup&gt; +
2&lt;sup&gt;m&lt;/sup&gt; + &amp;hellip; + n&lt;sup&gt;m&lt;/sup&gt;
for a fixed m and appear in many other places. This entry provides
three different definitions for them: a recursive one, an explicit
one, and one through their exponential generating function.&lt;/p&gt;
&lt;p&gt;In addition, we prove some basic facts, e.g. their relation
to sums of powers of integers and that all odd Bernoulli numbers
except the first are zero. We also prove the correctness of the
Akiyama&amp;ndash;Tanigawa algorithm for computing Bernoulli numbers
with reasonable efficiency, and we define the periodic Bernoulli
polynomials (which appear e.g. in the Euler&amp;ndash;MacLaurin
summation formula and the expansion of the log-Gamma function) and
prove their basic properties.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Minimal Static Single Assignment Form</title>
              <link>https://www.isa-afp.org/entries/Minimal_SSA.shtml</link>
       <guid>https://www.isa-afp.org/entries/Minimal_SSA.shtml</guid>
       <dc:creator> Max Wagner, Denis Lohner       </dc:creator>
       <pubDate>17 Jan 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This formalization is an extension to &lt;a
href=&#34;https://www.isa-afp.org/entries/Formal_SSA.shtml&#34;&gt;&#34;Verified
Construction of Static Single Assignment Form&#34;&lt;/a&gt;. In
their work, the authors have shown that &lt;a
href=&#34;http://dx.doi.org/10.1007/978-3-642-37051-9_6&#34;&gt;Braun
et al.&#39;s static single assignment (SSA) construction
algorithm&lt;/a&gt; produces minimal SSA form for input programs with
a reducible control flow graph (CFG). However Braun et al. also
proposed an extension to their algorithm that they claim produces
minimal SSA form even for irreducible CFGs.&lt;br&gt; In this
formalization we support that claim by giving a mechanized proof.
&lt;/p&gt;
&lt;p&gt;As the extension of Braun et al.&#39;s algorithm
aims for removing so-called redundant strongly connected components of
phi functions, we show that this suffices to guarantee minimality
according to &lt;a href=&#34;http://dx.doi.org/10.1145/115372.115320&#34;&gt;Cytron et
al.&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Bertrand's postulate</title>
              <link>https://www.isa-afp.org/entries/Bertrands_Postulate.shtml</link>
       <guid>https://www.isa-afp.org/entries/Bertrands_Postulate.shtml</guid>
       <dc:creator> Julian Biendarra, Manuel Eberl       </dc:creator>
       <pubDate>17 Jan 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;Bertrand&#39;s postulate is an early result on the
distribution of prime numbers: For every positive integer n, there
exists a prime number that lies strictly between n and 2n.
The proof is ported from John Harrison&#39;s formalisation
in HOL Light. It proceeds by first showing that the property is true
for all n greater than or equal to 600 and then showing that it also
holds for all n below 600 by case distinction. &lt;/p&gt;</description>
    </item>
    <item>
       <title>The Transcendence of e</title>
              <link>https://www.isa-afp.org/entries/E_Transcendental.shtml</link>
       <guid>https://www.isa-afp.org/entries/E_Transcendental.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>12 Jan 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This work contains a proof that Euler&#39;s number e is transcendental. The
proof follows the standard approach of assuming that e is algebraic and
then using a specific integer polynomial to derive two inconsistent bounds,
leading to a contradiction.&lt;/p&gt; &lt;p&gt;This kind of approach can be found in
many different sources; this formalisation mostly follows a &lt;a  href=&#34;http://planetmath.org/proofoflindemannweierstrasstheoremandthateandpiaretranscendental&#34;&gt;PlanetMath article&lt;/a&gt; by Roger Lipsett.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Formal Network Models and Their Application to Firewall Policies</title>
              <link>https://www.isa-afp.org/entries/UPF_Firewall.shtml</link>
       <guid>https://www.isa-afp.org/entries/UPF_Firewall.shtml</guid>
       <dc:creator> Achim D. Brucker, Lukas Brügger, Burkhart Wolff       </dc:creator>
       <pubDate>08 Jan 2017 00:00:00 +0000</pubDate>
       <description>
We present a formal model of network protocols and their application
to modeling firewall policies. The formalization is based on the
Unified Policy Framework (UPF). The formalization was originally
developed with for generating test cases for testing the security
configuration actual firewall and router (middle-boxes) using
HOL-TestGen. Our work focuses on modeling application level protocols
on top of tcp/ip.</description>
    </item>
    <item>
       <title>Verification of a Diffie-Hellman Password-based Authentication Protocol by Extending the Inductive Method</title>
              <link>https://www.isa-afp.org/entries/Password_Authentication_Protocol.shtml</link>
       <guid>https://www.isa-afp.org/entries/Password_Authentication_Protocol.shtml</guid>
       <dc:creator> Pasquale Noce       </dc:creator>
       <pubDate>03 Jan 2017 00:00:00 +0000</pubDate>
       <description>
This paper constructs a formal model of a Diffie-Hellman
password-based authentication protocol between a user and a smart
card, and proves its security. The protocol provides for the dispatch
of the user&#39;s password to the smart card on a secure messaging
channel established by means of Password Authenticated Connection
Establishment (PACE), where the mapping method being used is Chip
Authentication Mapping. By applying and suitably extending
Paulson&#39;s Inductive Method, this paper proves that the protocol
establishes trustworthy secure messaging channels, preserves the
secrecy of users&#39; passwords, and provides an effective mutual
authentication service. What is more, these security properties turn
out to hold independently of the secrecy of the PACE authentication
key.</description>
    </item>
    <item>
       <title>First-Order Logic According to Harrison</title>
              <link>https://www.isa-afp.org/entries/FOL_Harrison.shtml</link>
       <guid>https://www.isa-afp.org/entries/FOL_Harrison.shtml</guid>
       <dc:creator> Alexander Birch Jensen, Anders Schlichtkrull, Jørgen Villadsen       </dc:creator>
       <pubDate>01 Jan 2017 00:00:00 +0000</pubDate>
       <description>
We present a certified declarative first-order prover with equality
based on John Harrison&#39;s Handbook of Practical Logic and
Automated Reasoning, Cambridge University Press, 2009. ML code
reflection is used such that the entire prover can be executed within
Isabelle as a very simple interactive proof assistant. As examples we
consider Pelletier&#39;s problems 1-46.</description>
    </item>
    <item>
       <title>Concurrent Refinement Algebra and Rely Quotients</title>
              <link>https://www.isa-afp.org/entries/Concurrent_Ref_Alg.shtml</link>
       <guid>https://www.isa-afp.org/entries/Concurrent_Ref_Alg.shtml</guid>
       <dc:creator> Julian Fell, Ian Hayes, Andrius Velykis       </dc:creator>
       <pubDate>30 Dec 2016 00:00:00 +0000</pubDate>
       <description>
The concurrent refinement algebra developed here is designed to
provide a foundation for rely/guarantee reasoning about concurrent
programs. The algebra builds on a complete lattice of commands by
providing sequential composition, parallel composition and a novel
weak conjunction operator. The weak conjunction operator coincides
with the lattice supremum providing its arguments are non-aborting,
but aborts if either of its arguments do. Weak conjunction provides an
abstract version of a guarantee condition as a guarantee process. We
distinguish between models that distribute sequential composition over
non-deterministic choice from the left (referred to as being
conjunctive in the refinement calculus literature) and those that
don&#39;t. Least and greatest fixed points of monotone functions are
provided to allow recursion and iteration operators to be added to the
language. Additional iteration laws are available for conjunctive
models. The rely quotient of processes &lt;i&gt;c&lt;/i&gt; and
&lt;i&gt;i&lt;/i&gt; is the process that, if executed in parallel with
&lt;i&gt;i&lt;/i&gt; implements &lt;i&gt;c&lt;/i&gt;. It represents an
abstract version of a rely condition generalised to a process.</description>
    </item>
    <item>
       <title>The Twelvefold Way</title>
              <link>https://www.isa-afp.org/entries/Twelvefold_Way.shtml</link>
       <guid>https://www.isa-afp.org/entries/Twelvefold_Way.shtml</guid>
       <dc:creator> Lukas Bulwahn       </dc:creator>
       <pubDate>29 Dec 2016 00:00:00 +0000</pubDate>
       <description>
This entry provides all cardinality theorems of the Twelvefold Way.
The Twelvefold Way systematically classifies twelve related
combinatorial problems concerning two finite sets, which include
counting permutations, combinations, multisets, set partitions and
number partitions. This development builds upon the existing formal
developments with cardinality theorems for those structures. It
provides twelve bijections from the various structures to different
equivalence classes on finite functions, and hence, proves cardinality
formulae for these equivalence classes on finite functions.</description>
    </item>
    <item>
       <title>Proof Strategy Language</title>
              <link>https://www.isa-afp.org/entries/Proof_Strategy_Language.shtml</link>
       <guid>https://www.isa-afp.org/entries/Proof_Strategy_Language.shtml</guid>
       <dc:creator> Yutaka Nagashima       </dc:creator>
       <pubDate>20 Dec 2016 00:00:00 +0000</pubDate>
       <description>
Isabelle includes various automatic tools for finding proofs under
certain conditions. However, for each conjecture, knowing which
automation to use, and how to tweak its parameters, is currently
labour intensive. We have developed a language, PSL, designed to
capture high level proof strategies. PSL offloads the construction of
human-readable fast-to-replay proof scripts to automatic search,
making use of search-time information about each conjecture. Our
preliminary evaluations show that PSL reduces the labour cost of
interactive theorem proving. This submission contains the
implementation of PSL and an example theory file, Example.thy, showing
how to write poof strategies in PSL.</description>
    </item>
    <item>
       <title>Paraconsistency</title>
              <link>https://www.isa-afp.org/entries/Paraconsistency.shtml</link>
       <guid>https://www.isa-afp.org/entries/Paraconsistency.shtml</guid>
       <dc:creator> Anders Schlichtkrull, Jørgen Villadsen       </dc:creator>
       <pubDate>07 Dec 2016 00:00:00 +0000</pubDate>
       <description>
Paraconsistency is about handling inconsistency in a coherent way. In
classical and intuitionistic logic everything follows from an
inconsistent theory. A paraconsistent logic avoids the explosion.
Quite a few applications in computer science and engineering are
discussed in the Intelligent Systems Reference Library Volume 110:
Towards Paraconsistent Engineering (Springer 2016). We formalize a
paraconsistent many-valued logic that we motivated and described in a
special issue on logical approaches to paraconsistency (Journal of
Applied Non-Classical Logics 2005). We limit ourselves to the
propositional fragment of the higher-order logic. The logic is based
on so-called key equalities and has a countably infinite number of
truth values. We prove theorems in the logic using the definition of
validity. We verify truth tables and also counterexamples for
non-theorems. We prove meta-theorems about the logic and finally we
investigate a case study.</description>
    </item>
    <item>
       <title>COMPLX: A Verification Framework for Concurrent Imperative Programs</title>
              <link>https://www.isa-afp.org/entries/Complx.shtml</link>
       <guid>https://www.isa-afp.org/entries/Complx.shtml</guid>
       <dc:creator> Sidney Amani, June Andronick, Maksym Bortin, Corey Lewis, Christine Rizkallah, Joseph Tuong       </dc:creator>
       <pubDate>29 Nov 2016 00:00:00 +0000</pubDate>
       <description>
We propose a concurrency reasoning framework for imperative programs,
based on the Owicki-Gries (OG) foundational shared-variable
concurrency method. Our framework combines the approaches of
Hoare-Parallel, a formalisation of OG in Isabelle/HOL for a simple
while-language, and Simpl, a generic imperative language embedded in
Isabelle/HOL, allowing formal reasoning on C programs. We define the
Complx language, extending the syntax and semantics of Simpl with
support for parallel composition and synchronisation. We additionally
define an OG logic, which we prove sound w.r.t. the  semantics, and a
verification condition generator, both supporting involved low-level
imperative constructs such as function calls and abrupt termination.
We illustrate our framework on an example that features exceptions,
guards and function calls.  We aim to then target concurrent operating
systems, such as the interruptible eChronos embedded operating system
for which we already have a model-level OG proof using Hoare-Parallel.</description>
    </item>
  </channel>
</rss>
