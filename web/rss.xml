<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>21 Jun 2019 00:00:00 +0000</pubDate>
    <item>
       <title>Linear Inequalities</title>
              <link>https://www.isa-afp.org/entries/Linear_Inequalities.html</link>
       <guid>https://www.isa-afp.org/entries/Linear_Inequalities.html</guid>
       <dc:creator> Ralph Bottesch, Alban Reynaud, René Thiemann       </dc:creator>
       <pubDate>21 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We formalize results about linear inqualities, mainly from
Schrijver&#39;s book. The main results are the proof of the
fundamental theorem on linear inequalities, Farkas&#39; lemma,
Carathéodory&#39;s theorem, the Farkas-Minkowsky-Weyl theorem, the
decomposition theorem of polyhedra, and Meyer&#39;s result that the
integer hull of a polyhedron is a polyhedron itself. Several theorems
include bounds on the appearing numbers, and in particular we provide
an a-priori bound on mixed-integer solutions of linear inequalities.</description>
    </item>
    <item>
       <title>Hilbert's Nullstellensatz</title>
              <link>https://www.isa-afp.org/entries/Nullstellensatz.html</link>
       <guid>https://www.isa-afp.org/entries/Nullstellensatz.html</guid>
       <dc:creator> Alexander Maletzky       </dc:creator>
       <pubDate>16 Jun 2019 00:00:00 +0000</pubDate>
       <description>
This entry formalizes Hilbert&#39;s Nullstellensatz, an important
theorem in algebraic geometry that can be viewed as the generalization
of the Fundamental Theorem of Algebra to multivariate polynomials: If
a set of (multivariate) polynomials over an algebraically closed field
has no common zero, then the ideal it generates is the entire
polynomial ring. The formalization proves several equivalent versions
of this celebrated theorem: the weak Nullstellensatz, the strong
Nullstellensatz (connecting algebraic varieties and radical ideals),
and the field-theoretic Nullstellensatz. The formalization follows
Chapter 4.1. of &lt;a
href=&#34;https://link.springer.com/book/10.1007/978-0-387-35651-8&#34;&gt;Ideals,
Varieties, and Algorithms&lt;/a&gt; by Cox, Little and O&#39;Shea.</description>
    </item>
    <item>
       <title>Gröbner Bases, Macaulay Matrices and Dubé's Degree Bounds</title>
              <link>https://www.isa-afp.org/entries/Groebner_Macaulay.html</link>
       <guid>https://www.isa-afp.org/entries/Groebner_Macaulay.html</guid>
       <dc:creator> Alexander Maletzky       </dc:creator>
       <pubDate>15 Jun 2019 00:00:00 +0000</pubDate>
       <description>
This entry formalizes the connection between Gröbner bases and
Macaulay matrices (sometimes also referred to as `generalized
Sylvester matrices&#39;). In particular, it contains a method for
computing Gröbner bases, which proceeds by first constructing some
Macaulay matrix of the initial set of polynomials, then row-reducing
this matrix, and finally converting the result back into a set of
polynomials. The output is shown to be a Gröbner basis if the Macaulay
matrix constructed in the first step is sufficiently large. In order
to obtain concrete upper bounds on the size of the matrix (and hence
turn the method into an effectively executable algorithm), Dubé&#39;s
degree bounds on Gröbner bases are utilized; consequently, they are
also part of the formalization.</description>
    </item>
    <item>
       <title>Binary Heaps for IMP2</title>
              <link>https://www.isa-afp.org/entries/IMP2_Binary_Heap.html</link>
       <guid>https://www.isa-afp.org/entries/IMP2_Binary_Heap.html</guid>
       <dc:creator> Simon Griebel       </dc:creator>
       <pubDate>13 Jun 2019 00:00:00 +0000</pubDate>
       <description>
In this submission array-based binary minimum heaps are formalized.
The correctness of the following heap operations is proved: insert,
get-min, delete-min and make-heap. These are then used to verify an
in-place heapsort. The formalization is based on IMP2, an imperative
program verification framework implemented in Isabelle/HOL. The
verified heap functions are iterative versions of the partly recursive
functions found in &#34;Algorithms and Data Structures – The Basic
Toolbox&#34; by K. Mehlhorn and P. Sanders and &#34;Introduction to
Algorithms&#34; by T. H. Cormen, C. E. Leiserson, R. L. Rivest and C.
Stein.</description>
    </item>
    <item>
       <title>Differential Game Logic</title>
              <link>https://www.isa-afp.org/entries/Differential_Game_Logic.html</link>
       <guid>https://www.isa-afp.org/entries/Differential_Game_Logic.html</guid>
       <dc:creator> André Platzer       </dc:creator>
       <pubDate>03 Jun 2019 00:00:00 +0000</pubDate>
       <description>
This formalization provides differential game logic (dGL), a logic for
proving properties of hybrid game. In addition to the syntax and
semantics, it formalizes a uniform substitution calculus for dGL.
Church&#39;s uniform substitutions substitute a term or formula for a
function or predicate symbol everywhere. The uniform substitutions for
dGL also substitute hybrid games for a game symbol everywhere. We
prove soundness of one-pass uniform substitutions and the axioms of
differential game logic with respect to their denotational semantics.
One-pass uniform substitutions are faster by postponing
soundness-critical admissibility checks with a linear pass homomorphic
application and regain soundness by a variable condition at the
replacements.  The formalization is based on prior non-mechanized
soundness proofs for dGL.</description>
    </item>
    <item>
       <title>Multidimensional Binary Search Trees</title>
              <link>https://www.isa-afp.org/entries/KD_Tree.html</link>
       <guid>https://www.isa-afp.org/entries/KD_Tree.html</guid>
       <dc:creator> Martin Rau       </dc:creator>
       <pubDate>30 May 2019 00:00:00 +0000</pubDate>
       <description>
This entry provides a formalization of multidimensional binary trees,
also known as k-d trees. It includes a balanced build algorithm as
well as the nearest neighbor algorithm and the range search algorithm.
It is based on the papers &lt;a
href=&#34;https://dl.acm.org/citation.cfm?doid=361002.361007&#34;&gt;Multidimensional
binary search trees used for associative searching&lt;/a&gt; and &lt;a
href=&#34;https://dl.acm.org/citation.cfm?doid=355744.355745&#34;&gt;
An Algorithm for Finding Best Matches in Logarithmic Expected
Time&lt;/a&gt;.</description>
    </item>
    <item>
       <title>Formalization of Generic Authenticated Data Structures</title>
              <link>https://www.isa-afp.org/entries/LambdaAuth.html</link>
       <guid>https://www.isa-afp.org/entries/LambdaAuth.html</guid>
       <dc:creator> Matthias Brun, Dmitriy Traytel       </dc:creator>
       <pubDate>14 May 2019 00:00:00 +0000</pubDate>
       <description>
Authenticated data structures are a technique for outsourcing data
storage and maintenance to an untrusted server. The server is required
to produce an efficiently checkable and cryptographically secure proof
that it carried out precisely the requested computation. &lt;a
href=&#34;https://doi.org/10.1145/2535838.2535851&#34;&gt;Miller et
al.&lt;/a&gt; introduced &amp;lambda;&amp;bull; (pronounced
&lt;i&gt;lambda auth&lt;/i&gt;)&amp;mdash;a functional programming
language with a built-in primitive authentication construct, which
supports a wide range of user-specified authenticated data structures
while guaranteeing certain correctness and security properties for all
well-typed programs. We formalize &amp;lambda;&amp;bull; and prove its
correctness and security properties. With Isabelle&#39;s help, we
uncover and repair several mistakes in the informal proofs and lemma
statements. Our findings are summarized in a &lt;a
href=&#34;http://people.inf.ethz.ch/trayteld/papers/lambdaauth/lambdaauth.pdf&#34;&gt;paper
draft&lt;/a&gt;.</description>
    </item>
    <item>
       <title>Multi-Party Computation</title>
              <link>https://www.isa-afp.org/entries/Multi_Party_Computation.html</link>
       <guid>https://www.isa-afp.org/entries/Multi_Party_Computation.html</guid>
       <dc:creator> David Aspinall, David Butler       </dc:creator>
       <pubDate>09 May 2019 00:00:00 +0000</pubDate>
       <description>
We use CryptHOL to consider Multi-Party Computation (MPC) protocols.
MPC was first considered by Yao in 1983 and recent advances in
efficiency and an increased demand mean it is now deployed in the real
world. Security is considered using the real/ideal world paradigm. We
first define security in the semi-honest security setting where
parties are assumed not to deviate from the protocol transcript. In
this setting we prove multiple Oblivious Transfer (OT) protocols
secure and then show security for the gates of the GMW protocol. We
then define malicious security, this is a stronger notion of security
where parties are assumed to be fully corrupted by an adversary. In
this setting we again consider OT, as it is a fundamental building
block of almost all MPC protocols.</description>
    </item>
    <item>
       <title>HOL-CSP Version 2.0</title>
              <link>https://www.isa-afp.org/entries/HOL-CSP.html</link>
       <guid>https://www.isa-afp.org/entries/HOL-CSP.html</guid>
       <dc:creator> Safouan Taha, Lina Ye, Burkhart Wolff       </dc:creator>
       <pubDate>26 Apr 2019 00:00:00 +0000</pubDate>
       <description>
This is a complete formalization of the work of Hoare and Roscoe on
the denotational semantics of the Failure/Divergence Model of CSP. It
follows essentially the presentation of CSP in Roscoe’s Book ”Theory
and Practice of Concurrency” [8] and the semantic details in a joint
Paper of Roscoe and Brooks ”An improved failures model for
communicating processes&#34;.  The present work is based on a prior
formalization attempt, called HOL-CSP 1.0, done in 1997 by H. Tej and
B. Wolff with the Isabelle proof technology available at that time.
This work revealed minor, but omnipresent foundational errors in key
concepts like the process invariant. The present version HOL-CSP
profits from substantially improved libraries (notably HOLCF),
improved automated proof techniques, and structured proof techniques
in Isar and is substantially shorter but more complete.</description>
    </item>
    <item>
       <title>A Compositional and Unified Translation of LTL into ω-Automata</title>
              <link>https://www.isa-afp.org/entries/LTL_Master_Theorem.html</link>
       <guid>https://www.isa-afp.org/entries/LTL_Master_Theorem.html</guid>
       <dc:creator> Benedikt Seidl, Salomon Sickert       </dc:creator>
       <pubDate>16 Apr 2019 00:00:00 +0000</pubDate>
       <description>
We present a formalisation of the unified translation approach of
linear temporal logic (LTL) into ω-automata from [1]. This approach
decomposes LTL formulas into ``simple&#39;&#39; languages and allows
a clear separation of concerns: first, we formalise the purely logical
result yielding this decomposition; second, we instantiate this
generic theory to obtain a construction for deterministic
(state-based) Rabin automata (DRA). We extract from this particular
instantiation an executable tool translating LTL to DRAs. To the best
of our knowledge this is the first verified translation from LTL to
DRAs that is proven to be double exponential in the worst case which
asymptotically matches the known lower bound.
&lt;p&gt;
[1] Javier Esparza, Jan Kretínský, Salomon Sickert. One Theorem to Rule Them All:
A Unified Translation of LTL into ω-Automata. LICS 2018</description>
    </item>
    <item>
       <title>A General Theory of Syntax with Bindings</title>
              <link>https://www.isa-afp.org/entries/Binding_Syntax_Theory.html</link>
       <guid>https://www.isa-afp.org/entries/Binding_Syntax_Theory.html</guid>
       <dc:creator> Lorenzo Gheri, Andrei Popescu       </dc:creator>
       <pubDate>06 Apr 2019 00:00:00 +0000</pubDate>
       <description>
We formalize a theory of syntax with bindings that has been developed
and refined over the last decade to support several large
formalization efforts. Terms are defined for an arbitrary number of
constructors of varying numbers of inputs, quotiented to
alpha-equivalence and sorted according to a binding signature. The
theory includes many properties of the standard operators on terms:
substitution, swapping and freshness. It also includes bindings-aware
induction and recursion principles and support for semantic
interpretation. This work has been presented in the ITP 2017 paper “A
Formalized General Theory of Syntax with Bindings”.</description>
    </item>
    <item>
       <title>The Transcendence of Certain Infinite Series</title>
              <link>https://www.isa-afp.org/entries/Transcendence_Series_Hancl_Rucki.html</link>
       <guid>https://www.isa-afp.org/entries/Transcendence_Series_Hancl_Rucki.html</guid>
       <dc:creator> Angeliki Koutsoukou-Argyraki, Wenda Li       </dc:creator>
       <pubDate>27 Mar 2019 00:00:00 +0000</pubDate>
       <description>
We formalize the proofs of two transcendence criteria by J. Hančl
and P. Rucki that assert the transcendence of the sums of certain
infinite series built up by sequences that fulfil certain properties.
Both proofs make use of Roth&#39;s celebrated theorem on diophantine
approximations to algebraic numbers from 1955  which we implement as
an assumption without having formalised its proof.</description>
    </item>
    <item>
       <title>Quantum Hoare Logic</title>
              <link>https://www.isa-afp.org/entries/QHLProver.html</link>
       <guid>https://www.isa-afp.org/entries/QHLProver.html</guid>
       <dc:creator> Junyi Liu, Bohua Zhan, Shuling Wang, Shenggang Ying, Tao Liu, Yangjia Li, Mingsheng Ying, Naijun Zhan       </dc:creator>
       <pubDate>24 Mar 2019 00:00:00 +0000</pubDate>
       <description>
We formalize quantum Hoare logic as given in [1]. In particular, we
specify the syntax and denotational semantics of a simple model of
quantum programs. Then, we write down the rules of quantum Hoare logic
for partial correctness, and show the soundness and completeness of
the resulting proof system. As an application, we verify the
correctness of Grover’s algorithm.</description>
    </item>
    <item>
       <title>Safe OCL</title>
              <link>https://www.isa-afp.org/entries/Safe_OCL.html</link>
       <guid>https://www.isa-afp.org/entries/Safe_OCL.html</guid>
       <dc:creator> Denis Nikiforov       </dc:creator>
       <pubDate>09 Mar 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The theory is a formalization of the
&lt;a href=&#34;https://www.omg.org/spec/OCL/&#34;&gt;OCL&lt;/a&gt; type system, its abstract
syntax and expression typing rules. The theory does not define a concrete
syntax and a semantics. In contrast to
&lt;a href=&#34;https://www.isa-afp.org/entries/Featherweight_OCL.html&#34;&gt;Featherweight OCL&lt;/a&gt;,
it is based on a deep embedding approach. The type system is defined from scratch,
it is not based on the Isabelle HOL type system.&lt;/p&gt;
&lt;p&gt;The Safe OCL distincts nullable and non-nullable types. Also the theory gives a
formal definition of &lt;a href=&#34;http://ceur-ws.org/Vol-1512/paper07.pdf&#34;&gt;safe
navigation operations&lt;/a&gt;. The Safe OCL typing rules are much stricter than rules
given in the OCL specification. It allows one to catch more errors on a type
checking phase.&lt;/p&gt;
&lt;p&gt;The type theory presented is four-layered: classes, basic types, generic types,
errorable types. We introduce the following new types: non-nullable types (T[1]),
nullable types (T[?]), OclSuper. OclSuper is a supertype of all other types (basic
types, collections, tuples). This type allows us to define a total supremum function,
so types form an upper semilattice. It allows us to define rich expression typing
rules in an elegant manner.&lt;/p&gt;
&lt;p&gt;The Preliminaries Chapter of the theory defines a number of helper lemmas for
transitive closures and tuples. It defines also a generic object model independent
from OCL. It allows one to use the theory as a reference for formalization of analogous languages.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Elementary Facts About the Distribution of Primes</title>
              <link>https://www.isa-afp.org/entries/Prime_Distribution_Elementary.html</link>
       <guid>https://www.isa-afp.org/entries/Prime_Distribution_Elementary.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>21 Feb 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry is a formalisation of Chapter 4 (and parts of
Chapter 3) of Apostol&#39;s &lt;a
href=&#34;https://www.springer.com/de/book/9780387901633&#34;&gt;&lt;em&gt;Introduction
to Analytic Number Theory&lt;/em&gt;&lt;/a&gt;. The main topics that
are addressed are properties of the distribution of prime numbers that
can be shown in an elementary way (i.&amp;thinsp;e. without the Prime
Number Theorem), the various equivalent forms of the PNT (which imply
each other in elementary ways), and consequences that follow from the
PNT in elementary ways. The latter include, most notably, asymptotic
bounds for the number of distinct prime factors of
&lt;em&gt;n&lt;/em&gt;, the divisor function
&lt;em&gt;d(n)&lt;/em&gt;, Euler&#39;s totient function
&lt;em&gt;&amp;phi;(n)&lt;/em&gt;, and
lcm(1,&amp;hellip;,&lt;em&gt;n&lt;/em&gt;).&lt;/p&gt;</description>
    </item>
    <item>
       <title>Kruskal's Algorithm for Minimum Spanning Forest</title>
              <link>https://www.isa-afp.org/entries/Kruskal.html</link>
       <guid>https://www.isa-afp.org/entries/Kruskal.html</guid>
       <dc:creator> Maximilian P.L. Haslbeck, Peter Lammich, Julian Biendarra       </dc:creator>
       <pubDate>14 Feb 2019 00:00:00 +0000</pubDate>
       <description>
This Isabelle/HOL formalization defines a greedy algorithm for finding
a minimum weight basis on a weighted matroid and proves its
correctness. This algorithm is an abstract version of Kruskal&#39;s
algorithm.  We interpret the abstract algorithm for the cycle matroid
(i.e. forests in a graph) and refine it to imperative executable code
using an efficient union-find data structure.  Our formalization can
be instantiated for different graph representations. We provide
instantiations for undirected graphs and symmetric directed graphs.</description>
    </item>
    <item>
       <title>Probabilistic Primality Testing</title>
              <link>https://www.isa-afp.org/entries/Probabilistic_Prime_Tests.html</link>
       <guid>https://www.isa-afp.org/entries/Probabilistic_Prime_Tests.html</guid>
       <dc:creator> Daniel Stüwe, Manuel Eberl       </dc:creator>
       <pubDate>11 Feb 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The most efficient known primality tests are
&lt;em&gt;probabilistic&lt;/em&gt; in the sense that they use
randomness and may, with some probability, mistakenly classify a
composite number as prime &amp;ndash; but never a prime number as
composite. Examples of this are the Miller&amp;ndash;Rabin test, the
Solovay&amp;ndash;Strassen test, and (in most cases) Fermat&#39;s
test.&lt;/p&gt; &lt;p&gt;This entry defines these three tests and
proves their correctness. It also develops some of the
number-theoretic foundations, such as Carmichael numbers and the
Jacobi symbol with an efficient executable algorithm to compute
it.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Universal Turing Machine</title>
              <link>https://www.isa-afp.org/entries/Universal_Turing_Machine.html</link>
       <guid>https://www.isa-afp.org/entries/Universal_Turing_Machine.html</guid>
       <dc:creator> Jian Xu, Xingyuan Zhang, Christian Urban, Sebastiaan J. C. Joosten       </dc:creator>
       <pubDate>08 Feb 2019 00:00:00 +0000</pubDate>
       <description>
We formalise results from computability theory: recursive functions,
undecidability of the halting problem, and the existence of a
universal Turing machine. This formalisation is the AFP entry
corresponding to the paper Mechanising Turing Machines and Computability Theory
in Isabelle/HOL, ITP 2013.</description>
    </item>
    <item>
       <title>Isabelle/UTP: Mechanised Theory Engineering for Unifying Theories of Programming</title>
              <link>https://www.isa-afp.org/entries/UTP.html</link>
       <guid>https://www.isa-afp.org/entries/UTP.html</guid>
       <dc:creator> Simon Foster, Frank Zeyda, Yakoub Nemouchi, Pedro Ribeiro, Burkhart Wolff       </dc:creator>
       <pubDate>01 Feb 2019 00:00:00 +0000</pubDate>
       <description>
Isabelle/UTP is a mechanised theory engineering toolkit based on Hoare
and He’s Unifying Theories of Programming (UTP). UTP enables the
creation of denotational, algebraic, and operational semantics for
different programming languages using an alphabetised relational
calculus. We provide a semantic embedding of the alphabetised
relational calculus in Isabelle/HOL, including new type definitions,
relational constructors, automated proof tactics, and accompanying
algebraic laws. Isabelle/UTP can be used to both capture laws of
programming for different languages, and put these fundamental
theorems to work in the creation of associated verification tools,
using calculi like Hoare logics. This document describes the
relational core of the UTP in Isabelle/HOL.</description>
    </item>
    <item>
       <title>The Inversions of a List</title>
              <link>https://www.isa-afp.org/entries/List_Inversions.html</link>
       <guid>https://www.isa-afp.org/entries/List_Inversions.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>01 Feb 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry defines the set of &lt;em&gt;inversions&lt;/em&gt;
of a list, i.e. the pairs of indices that violate sortedness. It also
proves the correctness of the well-known
&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n log n&lt;/em&gt;)
divide-and-conquer algorithm to compute the number of
inversions.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Farkas' Lemma and Motzkin's Transposition Theorem</title>
              <link>https://www.isa-afp.org/entries/Farkas.html</link>
       <guid>https://www.isa-afp.org/entries/Farkas.html</guid>
       <dc:creator> Ralph Bottesch, Max W. Haslbeck, René Thiemann       </dc:creator>
       <pubDate>17 Jan 2019 00:00:00 +0000</pubDate>
       <description>
We formalize a proof of Motzkin&#39;s transposition theorem and
Farkas&#39; lemma in Isabelle/HOL. Our proof is based on the
formalization of the simplex algorithm which, given a set of linear
constraints, either returns a satisfying assignment to the problem or
detects unsatisfiability. By reusing facts about the simplex algorithm
we show that a set of linear constraints is unsatisfiable if and only
if there is a linear combination of the constraints which evaluates to
a trivially unsatisfiable inequality.</description>
    </item>
    <item>
       <title>IMP2 – Simple Program Verification in Isabelle/HOL</title>
              <link>https://www.isa-afp.org/entries/IMP2.html</link>
       <guid>https://www.isa-afp.org/entries/IMP2.html</guid>
       <dc:creator> Peter Lammich, Simon Wimmer       </dc:creator>
       <pubDate>15 Jan 2019 00:00:00 +0000</pubDate>
       <description>
IMP2 is a simple imperative language together with Isabelle tooling to
create a program verification environment in Isabelle/HOL. The tools
include a C-like syntax, a verification condition generator, and
Isabelle commands for the specification of programs. The framework is
modular, i.e., it allows easy reuse of already proved programs within
larger programs.  This entry comes with a quickstart guide and a large
collection of examples, spanning basic algorithms with simple proofs
to more advanced algorithms and proof techniques like data refinement.
Some highlights from the examples are: &lt;ul&gt; &lt;li&gt;Bisection
Square Root, &lt;/li&gt; &lt;li&gt;Extended Euclid,  &lt;/li&gt;
&lt;li&gt;Exponentiation by Squaring,  &lt;/li&gt; &lt;li&gt;Binary
Search,  &lt;/li&gt; &lt;li&gt;Insertion Sort,  &lt;/li&gt;
&lt;li&gt;Quicksort,  &lt;/li&gt; &lt;li&gt;Depth First Search.
&lt;/li&gt; &lt;/ul&gt;  The abstract syntax and semantics are very
simple and well-documented. They are suitable to be used in a course,
as extension to the IMP language which comes with the Isabelle
distribution.  While this entry is limited to a simple imperative
language, the ideas could be extended to more sophisticated languages.</description>
    </item>
    <item>
       <title>An Algebra for Higher-Order Terms</title>
              <link>https://www.isa-afp.org/entries/Higher_Order_Terms.html</link>
       <guid>https://www.isa-afp.org/entries/Higher_Order_Terms.html</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>15 Jan 2019 00:00:00 +0000</pubDate>
       <description>
In this formalization, I introduce a higher-order term algebra,
generalizing the notions of free variables, matching, and
substitution. The need arose from the work on a &lt;a
href=&#34;http://dx.doi.org/10.1007/978-3-319-89884-1_35&#34;&gt;verified
compiler from Isabelle to CakeML&lt;/a&gt;. Terms can be thought of as
consisting of a generic (free variables, constants, application) and
a specific part. As example applications, this entry provides
instantiations for de-Bruijn terms, terms with named variables, and
&lt;a
href=&#34;https://www.isa-afp.org/entries/Lambda_Free_RPOs.html&#34;&gt;Blanchette’s
&amp;lambda;-free higher-order terms&lt;/a&gt;. Furthermore, I
implement translation functions between de-Bruijn terms and named
terms and prove their correctness.</description>
    </item>
    <item>
       <title>A Reduction Theorem for Store Buffers</title>
              <link>https://www.isa-afp.org/entries/Store_Buffer_Reduction.html</link>
       <guid>https://www.isa-afp.org/entries/Store_Buffer_Reduction.html</guid>
       <dc:creator> Ernie Cohen, Norbert Schirmer       </dc:creator>
       <pubDate>07 Jan 2019 00:00:00 +0000</pubDate>
       <description>
When verifying a concurrent program, it is usual to assume that memory
is sequentially consistent.  However, most modern multiprocessors
depend on store buffering for efficiency, and provide native
sequential consistency only at a substantial performance penalty.  To
regain sequential consistency, a programmer has to follow an
appropriate programming discipline. However, na&amp;iuml;ve disciplines,
such as protecting all shared accesses with locks, are not flexible
enough for building high-performance multiprocessor software.  We
present a new discipline for concurrent programming under TSO (total
store order, with store buffer forwarding). It does not depend on
concurrency primitives, such as locks. Instead, threads use ghost
operations to acquire and release ownership of memory addresses. A
thread can write to an address only if no other thread owns it, and
can read from an address only if it owns it or it is shared and the
thread has flushed its store buffer since it last wrote to an address
it did not own. This discipline covers both coarse-grained concurrency
(where data is protected by locks) as well as fine-grained concurrency
(where atomic operations race to memory).  We formalize this
discipline in Isabelle/HOL, and prove that if every execution of a
program in a system without store buffers follows the discipline, then
every execution of the program with store buffers is sequentially
consistent. Thus, we can show sequential consistency under TSO by
ordinary assertional reasoning about the program, without having to
consider store buffers at all.</description>
    </item>
    <item>
       <title>A Formal Model of the Document Object Model</title>
              <link>https://www.isa-afp.org/entries/Core_DOM.html</link>
       <guid>https://www.isa-afp.org/entries/Core_DOM.html</guid>
       <dc:creator> Achim D. Brucker, Michael Herzberg       </dc:creator>
       <pubDate>26 Dec 2018 00:00:00 +0000</pubDate>
       <description>
In this AFP entry, we formalize the core of the Document Object Model
(DOM).  At its core, the DOM defines a tree-like data structure for
representing documents in general and HTML documents in particular. It
is the heart of any modern web browser.  Formalizing the key concepts
of the DOM is a prerequisite for the formal reasoning over client-side
JavaScript programs and for the analysis of security concepts in
modern web browsers.  We present a formalization of the core DOM, with
focus on the node-tree and the operations defined on node-trees, in
Isabelle/HOL. We use the formalization to verify the functional
correctness of the most important functions defined in the DOM
standard. Moreover, our formalization is 1) extensible, i.e., can be
extended without the need of re-proving already proven properties and
2) executable, i.e., we can generate executable code from our
specification.</description>
    </item>
    <item>
       <title>Formalization of Concurrent Revisions</title>
              <link>https://www.isa-afp.org/entries/Concurrent_Revisions.html</link>
       <guid>https://www.isa-afp.org/entries/Concurrent_Revisions.html</guid>
       <dc:creator> Roy Overbeek       </dc:creator>
       <pubDate>25 Dec 2018 00:00:00 +0000</pubDate>
       <description>
Concurrent revisions is a concurrency control model developed by
Microsoft Research. It has many interesting properties that
distinguish it from other well-known models such as transactional
memory. One of these properties is &lt;em&gt;determinacy&lt;/em&gt;:
programs written within the model always produce the same outcome,
independent of scheduling activity. The concurrent revisions model has
an operational semantics, with an informal proof of determinacy. This
document contains an Isabelle/HOL formalization of this semantics and
the proof of determinacy.</description>
    </item>
    <item>
       <title>Verifying Imperative Programs using Auto2</title>
              <link>https://www.isa-afp.org/entries/Auto2_Imperative_HOL.html</link>
       <guid>https://www.isa-afp.org/entries/Auto2_Imperative_HOL.html</guid>
       <dc:creator> Bohua Zhan       </dc:creator>
       <pubDate>21 Dec 2018 00:00:00 +0000</pubDate>
       <description>
This entry contains the application of auto2 to verifying functional
and imperative programs. Algorithms and data structures that are
verified include linked lists, binary search trees, red-black trees,
interval trees, priority queue, quicksort, union-find, Dijkstra&#39;s
algorithm, and a sweep-line algorithm for detecting rectangle
intersection. The imperative verification is based on Imperative HOL
and its separation logic framework. A major goal of this work is to
set up automation in order to reduce the length of proof that the user
needs to provide, both for verifying functional programs and for
working with separation logic.</description>
    </item>
    <item>
       <title>Constructive Cryptography in HOL</title>
              <link>https://www.isa-afp.org/entries/Constructive_Cryptography.html</link>
       <guid>https://www.isa-afp.org/entries/Constructive_Cryptography.html</guid>
       <dc:creator> Andreas Lochbihler, S. Reza Sefidgar       </dc:creator>
       <pubDate>17 Dec 2018 00:00:00 +0000</pubDate>
       <description>
Inspired by Abstract Cryptography, we extend CryptHOL, a framework for
formalizing game-based proofs, with an abstract model of Random
Systems and provide proof rules about their composition and equality.
This foundation facilitates the formalization of Constructive
Cryptography proofs, where the security of a cryptographic scheme is
realized as a special form of construction in which a complex random
system is built from simpler ones. This is a first step towards a
fully-featured compositional framework, similar to Universal
Composability framework, that supports formalization of
simulation-based proofs.</description>
    </item>
    <item>
       <title>Transformer Semantics</title>
              <link>https://www.isa-afp.org/entries/Transformer_Semantics.html</link>
       <guid>https://www.isa-afp.org/entries/Transformer_Semantics.html</guid>
       <dc:creator> Georg Struth       </dc:creator>
       <pubDate>11 Dec 2018 00:00:00 +0000</pubDate>
       <description>
These mathematical components formalise predicate transformer
semantics for programs, yet currently only for partial correctness and
in the absence of faults.  A first part for isotone (or monotone),
Sup-preserving and Inf-preserving transformers follows Back and von
Wright&#39;s approach, with additional emphasis on the quantalic
structure of algebras of transformers.  The second part develops
Sup-preserving and Inf-preserving predicate transformers from the
powerset monad, via its Kleisli category and Eilenberg-Moore algebras,
with emphasis on adjunctions and dualities, as well as isomorphisms
between relations, state transformers and predicate transformers.</description>
    </item>
    <item>
       <title>Quantales</title>
              <link>https://www.isa-afp.org/entries/Quantales.html</link>
       <guid>https://www.isa-afp.org/entries/Quantales.html</guid>
       <dc:creator> Georg Struth       </dc:creator>
       <pubDate>11 Dec 2018 00:00:00 +0000</pubDate>
       <description>
These mathematical components formalise basic properties of quantales,
together with some important models, constructions, and concepts,
including quantic nuclei and conuclei.</description>
    </item>
  </channel>
</rss>
